// Copyright 2018 Google LLC. All Rights Reserved. This file and proprietary
// source code may only be used and distributed under the Widevine License
// Agreement.

// @generated by protoc-gen-es v2.10.1 with parameter "target=ts"
// @generated from file license_protocol.proto (package video_widevine, syntax proto2)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from '@bufbuild/protobuf/codegenv2'
import { enumDesc, fileDesc, messageDesc } from '@bufbuild/protobuf/codegenv2'
import type { Message } from '@bufbuild/protobuf'

/**
 * Describes the file license_protocol.proto.
 */
export const file_license_protocol: GenFile =
    /*@__PURE__*/
    fileDesc(
        'ChZsaWNlbnNlX3Byb3RvY29sLnByb3RvEg52aWRlb193aWRldmluZSJ4ChFSZW1vdGVBdHRlc3RhdGlvbhJCCgtjZXJ0aWZpY2F0ZRgBIAEoCzItLnZpZGVvX3dpZGV2aW5lLkVuY3J5cHRlZENsaWVudElkZW50aWZpY2F0aW9uEgwKBHNhbHQYAiABKAwSEQoJc2lnbmF0dXJlGAMgASgMIv8PCg5EVENQVXNhZ2VSdWxlcxIcCg1yZXF1aXJlX2R0Y3AyGAEgASgIOgVmYWxzZRJECgxjb3B5X2NvbnRyb2wYAiABKA4yLi52aWRlb193aWRldmluZS5EVENQVXNhZ2VSdWxlcy5Db3B5Q29udHJvbEluZm8SFwoPZW5jcnlwdGlvbl9wbHVzGAMgASgIEkYKD3JldGVudGlvbl9zdGF0ZRgEIAEoDjItLnZpZGVvX3dpZGV2aW5lLkRUQ1BVc2FnZVJ1bGVzLlJldGVudGlvblN0YXRlElcKGGFuYWxvZ19wcm90ZWN0aW9uX3N5c3RlbRgFIAEoDjI1LnZpZGVvX3dpZGV2aW5lLkRUQ1BVc2FnZVJ1bGVzLkFuYWxvZ1Byb3RlY3Rpb25TeXN0ZW0SUwoWaW1hZ2VfY29uc3RyYWludF90b2tlbhgGIAEoDjIzLnZpZGVvX3dpZGV2aW5lLkRUQ1BVc2FnZVJ1bGVzLkltYWdlQ29uc3RyYWludFRva2VuEk0KE2FuYWxvZ19zdW5zZXRfdG9rZW4YByABKA4yMC52aWRlb193aWRldmluZS5EVENQVXNhZ2VSdWxlcy5BbmFsb2dTdW5zZXRUb2tlbhJLChJkaWdpdGFsX29ubHlfdG9rZW4YCCABKA4yLy52aWRlb193aWRldmluZS5EVENQVXNhZ2VSdWxlcy5EaWdpdGFsT25seVRva2VuEk8KFGF1ZGlvX2VuaGFuY2VkX3Rva2VuGAkgASgOMjEudmlkZW9fd2lkZXZpbmUuRFRDUFVzYWdlUnVsZXMuQXVkaW9FbmhhbmNlZFRva2VuEhIKCmNvcHlfY291bnQYCiABKA0SWQoWc3RhbmRhcmRfZGlnaXRhbF90b2tlbhgLIAEoDjI5LnZpZGVvX3dpZGV2aW5lLkRUQ1BVc2FnZVJ1bGVzLlN0YW5kYXJkRGlnaXRhbE91dHB1dFRva2VuElAKEmhpZ2hfZHluYW1pY190b2tlbhgMIAEoDjI0LnZpZGVvX3dpZGV2aW5lLkRUQ1BVc2FnZVJ1bGVzLkhpZ2hEeW5hbWljUmFuZ2VUb2tlbhJLCg1sMl9vbmx5X3Rva2VuGA0gASgOMjQudmlkZW9fd2lkZXZpbmUuRFRDUFVzYWdlUnVsZXMuTDJQcm90ZWN0aW9uT25seVRva2VuEk4KE2VuaGFuZWRfaW1hZ2VfdG9rZW4YDiABKA4yMS52aWRlb193aWRldmluZS5EVENQVXNhZ2VSdWxlcy5FbmhhbmNlZEltYWdlVG9rZW4SFgoOcmV0ZW50aW9uX3RpbWUYDyABKA0SRQoMZnVydGhlcl9jb3B5GBAgASgOMi8udmlkZW9fd2lkZXZpbmUuRFRDUFVzYWdlUnVsZXMuRnVydGhlckJvdW5kQ29weSL4AQoOUmV0ZW50aW9uU3RhdGUSGwoXUkVURU5USU9OX1NUQVRFX0ZPUkVWRVIQABIaChZSRVRFTlRJT05fU1RBVEVfMV9XRUVLEAESGgoWUkVURU5USU9OX1NUQVRFXzJfREFZUxACEhkKFVJFVEVOVElPTl9TVEFURV8xX0RBWRADEhwKGFJFVEVOVElPTl9TVEFURV8xMl9IT1VSUxAEEhsKF1JFVEVOVElPTl9TVEFURV82X0hPVVJTEAUSGwoXUkVURU5USU9OX1NUQVRFXzNfSE9VUlMQBhIeChpSRVRFTlRJT05fU1RBVEVfOTBfTUlOVVRFUxAHIlAKD0NvcHlDb250cm9sSW5mbxINCglDT1BZX0ZSRUUQABIQCgxDT1BZX05PX01PUkUQARIMCghDT1BZX09ORRACEg4KCkNPUFlfTkVWRVIQAyJSChZBbmFsb2dQcm90ZWN0aW9uU3lzdGVtEgsKB0FQU19PRkYQABINCglBUFNfVFlQRTEQARINCglBUFNfVFlQRTIQAhINCglBUFNfVFlQRTMQAyI+ChRJbWFnZUNvbnN0cmFpbnRUb2tlbhITCg9JQ1RfQ09OU1RSQUlORUQQABIRCg1JQ1RfSERfQU5BTE9HEAEiOAoRQW5hbG9nU3Vuc2V0VG9rZW4SEAoMQVNUX0FTU0VSVEVEEAASEQoNQVNUX1VOQVNFUlRFRBABIjgKEERpZ2l0YWxPbmx5VG9rZW4SEAoMRE9UX0FTU0VSVEVEEAASEgoORE9UX1VOQVNTRVJURUQQASI6ChJBdWRpb0VuaGFuY2VkVG9rZW4SEAoMQUVUX0FTU0VSVEVEEAASEgoOQUVUX1VOQVNTRVJURUQQASJEChpTdGFuZGFyZERpZ2l0YWxPdXRwdXRUb2tlbhITCg9TRE9fVU5BU1NFRVJURUQQABIRCg1TRE9fQVNTRUVSVEVEEAEiPQoVSGlnaER5bmFtaWNSYW5nZVRva2VuEhIKDkhEUl9VTkFTU0VSVEVEEAASEAoMSERSX0FTU0VSVEVEEAEiRQoVTDJQcm90ZWN0aW9uT25seVRva2VuEhYKEkwyX09OTFlfVU5BU1NFUlRFRBAAEhQKEEwyX09OTFlfQVNTRVJURUQQASI4ChJFbmhhbmNlZEltYWdlVG9rZW4SEQoNRUlfVU5BU1NFUlRFRBAAEg8KC0VJX0FTU0VSVEVEEAEiOQoQRnVydGhlckJvdW5kQ29weRISCg5GQkNfUFJPSElCSVRFRBAAEhEKDUZCQ19QRVJNSVRURUQQASKHAwoVTGljZW5zZUlkZW50aWZpY2F0aW9uEhIKCnJlcXVlc3RfaWQYASABKAwSEgoKc2Vzc2lvbl9pZBgCIAEoDBITCgtwdXJjaGFzZV9pZBgDIAEoDBIpCgR0eXBlGAQgASgOMhsudmlkZW9fd2lkZXZpbmUuTGljZW5zZVR5cGUSDwoHdmVyc2lvbhgFIAEoBRIeChZwcm92aWRlcl9zZXNzaW9uX3Rva2VuGAYgASgMEigKIG9yaWdpbmFsX3JlbnRhbF9kdXJhdGlvbl9zZWNvbmRzGAcgASgDEioKIm9yaWdpbmFsX3BsYXliYWNrX2R1cmF0aW9uX3NlY29uZHMYCCABKAMSIwobb3JpZ2luYWxfc3RhcnRfdGltZV9zZWNvbmRzGAkgASgDEjIKKm9yaWdpbmFsX3JlbmV3YWxfcmVjb3ZlcnlfZHVyYXRpb25fc2Vjb25kcxgKIAEoAxImCh5vcmlnaW5hbF9yZW5ld2FsX2RlbGF5X3NlY29uZHMYCyABKAMiigIKE0xpY2Vuc2VDYXRlZ29yeVNwZWMSTQoQbGljZW5zZV9jYXRlZ29yeRgBIAEoDjIzLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VDYXRlZ29yeVNwZWMuTGljZW5zZUNhdGVnb3J5EhQKCmNvbnRlbnRfaWQYAiABKAxIABISCghncm91cF9pZBgDIAEoDEgAImMKD0xpY2Vuc2VDYXRlZ29yeRIiCh5TSU5HTEVfQ09OVEVOVF9MSUNFTlNFX0RFRkFVTFQQABIZChVNVUxUSV9DT05URU5UX0xJQ0VOU0UQARIRCg1HUk9VUF9MSUNFTlNFEAJCFQoTY29udGVudF9vcl9ncm91cF9pZCJeCglQcm94eUluZm8SPAoIc2RrX3R5cGUYASABKA4yKi52aWRlb193aWRldmluZS5Ecm1DZXJ0aWZpY2F0ZS5TZXJ2aWNlVHlwZRITCgtzZGtfdmVyc2lvbhgCIAEoCSLcIAoHTGljZW5zZRIxCgJpZBgBIAEoCzIlLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VJZGVudGlmaWNhdGlvbhIuCgZwb2xpY3kYAiABKAsyHi52aWRlb193aWRldmluZS5MaWNlbnNlLlBvbGljeRIxCgNrZXkYAyADKAsyJC52aWRlb193aWRldmluZS5MaWNlbnNlLktleUNvbnRhaW5lchIaChJsaWNlbnNlX3N0YXJ0X3RpbWUYBCABKAMSKgobcmVtb3RlX2F0dGVzdGF0aW9uX3ZlcmlmaWVkGAUgASgIOgVmYWxzZRIdChVwcm92aWRlcl9jbGllbnRfdG9rZW4YBiABKAwSGQoRcHJvdGVjdGlvbl9zY2hlbWUYByABKA0SFwoPc3JtX3JlcXVpcmVtZW50GAggASgMEhIKCnNybV91cGRhdGUYCSABKAwSagoccGxhdGZvcm1fdmVyaWZpY2F0aW9uX3N0YXR1cxgKIAEoDjIqLnZpZGVvX3dpZGV2aW5lLlBsYXRmb3JtVmVyaWZpY2F0aW9uU3RhdHVzOhhQTEFURk9STV9OT19WRVJJRklDQVRJT04SEQoJZ3JvdXBfaWRzGAsgAygMEkIKFWxpY2Vuc2VfY2F0ZWdvcnlfc3BlYxgMIAEoCzIjLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VDYXRlZ29yeVNwZWMSFwoPcHJvdmlkZXJfa2V5X2lkGA0gASgNGqIICgZQb2xpY3kSFwoIY2FuX3BsYXkYASABKAg6BWZhbHNlEhoKC2Nhbl9wZXJzaXN0GAIgASgIOgVmYWxzZRIYCgljYW5fcmVuZXcYAyABKAg6BWZhbHNlEiIKF3JlbnRhbF9kdXJhdGlvbl9zZWNvbmRzGAQgASgDOgEwEiQKGXBsYXliYWNrX2R1cmF0aW9uX3NlY29uZHMYBSABKAM6ATASIwoYbGljZW5zZV9kdXJhdGlvbl9zZWNvbmRzGAYgASgDOgEwEiwKIXJlbmV3YWxfcmVjb3ZlcnlfZHVyYXRpb25fc2Vjb25kcxgHIAEoAzoBMBIaChJyZW5ld2FsX3NlcnZlcl91cmwYCCABKAkSIAoVcmVuZXdhbF9kZWxheV9zZWNvbmRzGAkgASgDOgEwEikKHnJlbmV3YWxfcmV0cnlfaW50ZXJ2YWxfc2Vjb25kcxgKIAEoAzoBMBIfChByZW5ld193aXRoX3VzYWdlGAsgASgIOgVmYWxzZRInChhhbHdheXNfaW5jbHVkZV9jbGllbnRfaWQYDCABKAg6BWZhbHNlEioKH3BsYXlfc3RhcnRfZ3JhY2VfcGVyaW9kX3NlY29uZHMYDSABKAM6ATASLQoec29mdF9lbmZvcmNlX3BsYXliYWNrX2R1cmF0aW9uGA4gASgIOgVmYWxzZRIqChxzb2Z0X2VuZm9yY2VfcmVudGFsX2R1cmF0aW9uGA8gASgIOgR0cnVlEnIKFHdhdGVybWFya2luZ19jb250cm9sGBAgASgOMjIudmlkZW9fd2lkZXZpbmUuTGljZW5zZS5Qb2xpY3kuV2F0ZXJtYXJraW5nQ29udHJvbDogV0FURVJNQVJLSU5HX0NPTlRST0xfVU5TUEVDSUZJRUQSLQoFZHRjcDIYESABKAsyHi52aWRlb193aWRldmluZS5EVENQVXNhZ2VSdWxlcxJvChppbml0aWFsX3JlbmV3YWxfZGVsYXlfYmFzZRgSIAEoDjItLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2UuUG9saWN5LlRpbWVyRGVsYXlCYXNlOhxUSU1FUl9ERUxBWV9CQVNFX1VOU1BFQ0lGSUVEInIKE1dhdGVybWFya2luZ0NvbnRyb2wSJAogV0FURVJNQVJLSU5HX0NPTlRST0xfVU5TUEVDSUZJRUQQABIaChZXQVRFUk1BUktJTkdfRk9SQklEREVOEAESGQoVV0FURVJNQVJLSU5HX1JFUVVJUkVEEAIiagoOVGltZXJEZWxheUJhc2USIAocVElNRVJfREVMQVlfQkFTRV9VTlNQRUNJRklFRBAAEhEKDUxJQ0VOU0VfU1RBUlQQARIQCgxMSUNFTlNFX0xPQUQQAhIRCg1GSVJTVF9ERUNSWVBUEAMaihQKDEtleUNvbnRhaW5lchIKCgJpZBgBIAEoDBIKCgJpdhgCIAEoDBILCgNrZXkYAyABKAwSOgoEdHlwZRgEIAEoDjIsLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyLktleVR5cGUSUwoFbGV2ZWwYBSABKA4yMi52aWRlb193aWRldmluZS5MaWNlbnNlLktleUNvbnRhaW5lci5TZWN1cml0eUxldmVsOhBTV19TRUNVUkVfQ1JZUFRPElIKE3JlcXVpcmVkX3Byb3RlY3Rpb24YBiABKAsyNS52aWRlb193aWRldmluZS5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uElMKFHJlcXVlc3RlZF9wcm90ZWN0aW9uGAcgASgLMjUudmlkZW9fd2lkZXZpbmUuTGljZW5zZS5LZXlDb250YWluZXIuT3V0cHV0UHJvdGVjdGlvbhJECgtrZXlfY29udHJvbBgIIAEoCzIvLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyLktleUNvbnRyb2wSbAogb3BlcmF0b3Jfc2Vzc2lvbl9rZXlfcGVybWlzc2lvbnMYCSABKAsyQi52aWRlb193aWRldmluZS5MaWNlbnNlLktleUNvbnRhaW5lci5PcGVyYXRvclNlc3Npb25LZXlQZXJtaXNzaW9ucxJkChx2aWRlb19yZXNvbHV0aW9uX2NvbnN0cmFpbnRzGAogAygLMj4udmlkZW9fd2lkZXZpbmUuTGljZW5zZS5LZXlDb250YWluZXIuVmlkZW9SZXNvbHV0aW9uQ29uc3RyYWludBIoChlhbnRpX3JvbGxiYWNrX3VzYWdlX3RhYmxlGAsgASgIOgVmYWxzZRITCgt0cmFja19sYWJlbBgMIAEoCRJPChFrZXlfY2F0ZWdvcnlfc3BlYxgNIAEoCzI0LnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyLktleUNhdGVnb3J5U3BlYxJvChFlbmNyeXB0aW9uX3NjaGVtZRgOIAEoDjI1LnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyLkVuY3J5cHRpb25TY2hlbWU6HUVOQ1JZUFRJT05fU0NIRU1FX1VOU1BFQ0lGSUVEGjMKCktleUNvbnRyb2wSGQoRa2V5X2NvbnRyb2xfYmxvY2sYASABKAwSCgoCaXYYAiABKAwakgUKEE91dHB1dFByb3RlY3Rpb24SUwoEaGRjcBgBIAEoDjI6LnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyLk91dHB1dFByb3RlY3Rpb24uSERDUDoJSERDUF9OT05FElkKCmNnbXNfZmxhZ3MYAiABKA4yOi52aWRlb193aWRldmluZS5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkNHTVM6CUNHTVNfTk9ORRJsCg1oZGNwX3NybV9ydWxlGAMgASgOMkEudmlkZW9fd2lkZXZpbmUuTGljZW5zZS5LZXlDb250YWluZXIuT3V0cHV0UHJvdGVjdGlvbi5IZGNwU3JtUnVsZToSSERDUF9TUk1fUlVMRV9OT05FEiQKFWRpc2FibGVfYW5hbG9nX291dHB1dBgEIAEoCDoFZmFsc2USJQoWZGlzYWJsZV9kaWdpdGFsX291dHB1dBgFIAEoCDoFZmFsc2USGwoMYWxsb3dfcmVjb3JkGAYgASgIOgVmYWxzZSJ5CgRIRENQEg0KCUhEQ1BfTk9ORRAAEgsKB0hEQ1BfVjEQARILCgdIRENQX1YyEAISDQoJSERDUF9WMl8xEAMSDQoJSERDUF9WMl8yEAQSDQoJSERDUF9WMl8zEAUSGwoWSERDUF9OT19ESUdJVEFMX09VVFBVVBD/ASJDCgRDR01TEg0KCUNHTVNfTk9ORRAqEg0KCUNPUFlfRlJFRRAAEg0KCUNPUFlfT05DRRACEg4KCkNPUFlfTkVWRVIQAyI2CgtIZGNwU3JtUnVsZRIWChJIRENQX1NSTV9SVUxFX05PTkUQABIPCgtDVVJSRU5UX1NSTRABGq0BChlWaWRlb1Jlc29sdXRpb25Db25zdHJhaW50Eh0KFW1pbl9yZXNvbHV0aW9uX3BpeGVscxgBIAEoDRIdChVtYXhfcmVzb2x1dGlvbl9waXhlbHMYAiABKA0SUgoTcmVxdWlyZWRfcHJvdGVjdGlvbhgDIAEoCzI1LnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2UuS2V5Q29udGFpbmVyLk91dHB1dFByb3RlY3Rpb24anQEKHU9wZXJhdG9yU2Vzc2lvbktleVBlcm1pc3Npb25zEhwKDWFsbG93X2VuY3J5cHQYASABKAg6BWZhbHNlEhwKDWFsbG93X2RlY3J5cHQYAiABKAg6BWZhbHNlEhkKCmFsbG93X3NpZ24YAyABKAg6BWZhbHNlEiUKFmFsbG93X3NpZ25hdHVyZV92ZXJpZnkYBCABKAg6BWZhbHNlGugBCg9LZXlDYXRlZ29yeVNwZWMSVgoMa2V5X2NhdGVnb3J5GAEgASgOMkAudmlkZW9fd2lkZXZpbmUuTGljZW5zZS5LZXlDb250YWluZXIuS2V5Q2F0ZWdvcnlTcGVjLktleUNhdGVnb3J5EhQKCmNvbnRlbnRfaWQYAiABKAxIABISCghncm91cF9pZBgDIAEoDEgAIjwKC0tleUNhdGVnb3J5Eh4KGlNJTkdMRV9DT05URU5UX0tFWV9ERUZBVUxUEAASDQoJR1JPVVBfS0VZEAFCFQoTY29udGVudF9vcl9ncm91cF9pZCKnAQoHS2V5VHlwZRILCgdTSUdOSU5HEAESCwoHQ09OVEVOVBACEg8KC0tFWV9DT05UUk9MEAMSFAoQT1BFUkFUT1JfU0VTU0lPThAEEg8KC0VOVElUTEVNRU5UEAUSDwoLT0VNX0NPTlRFTlQQBhIkCiBQUk9WSURFUl9FQ01fVkVSSUZJRVJfUFVCTElDX0tFWRAHEhMKD09FTV9FTlRJVExFTUVOVBAIInoKDVNlY3VyaXR5TGV2ZWwSFAoQU1dfU0VDVVJFX0NSWVBUTxABEhQKEFNXX1NFQ1VSRV9ERUNPREUQAhIUChBIV19TRUNVUkVfQ1JZUFRPEAMSFAoQSFdfU0VDVVJFX0RFQ09ERRAEEhEKDUhXX1NFQ1VSRV9BTEwQBSJVChBFbmNyeXB0aW9uU2NoZW1lEiEKHUVOQ1JZUFRJT05fU0NIRU1FX1VOU1BFQ0lGSUVEEAASDgoKQUVTMTI4X0NUUhABEg4KCkFFUzEyOF9DQkMQAiKfDAoOTGljZW5zZVJlcXVlc3QSNwoJY2xpZW50X2lkGAEgASgLMiQudmlkZW9fd2lkZXZpbmUuQ2xpZW50SWRlbnRpZmljYXRpb24SSAoKY29udGVudF9pZBgCIAEoCzI0LnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbhI4CgR0eXBlGAMgASgOMioudmlkZW9fd2lkZXZpbmUuTGljZW5zZVJlcXVlc3QuUmVxdWVzdFR5cGUSFAoMcmVxdWVzdF90aW1lGAQgASgDEiQKHGtleV9jb250cm9sX25vbmNlX2RlcHJlY2F0ZWQYBSABKAwSRgoQcHJvdG9jb2xfdmVyc2lvbhgGIAEoDjIfLnZpZGVvX3dpZGV2aW5lLlByb3RvY29sVmVyc2lvbjoLVkVSU0lPTl8yXzASGQoRa2V5X2NvbnRyb2xfbm9uY2UYByABKA0SSgoTZW5jcnlwdGVkX2NsaWVudF9pZBgIIAEoCzItLnZpZGVvX3dpZGV2aW5lLkVuY3J5cHRlZENsaWVudElkZW50aWZpY2F0aW9uEhYKDmNsaWVudF92ZXJzaW9uGAkgASgJGpoIChVDb250ZW50SWRlbnRpZmljYXRpb24SYwoSd2lkZXZpbmVfcHNzaF9kYXRhGAEgASgLMkUudmlkZW9fd2lkZXZpbmUuTGljZW5zZVJlcXVlc3QuQ29udGVudElkZW50aWZpY2F0aW9uLldpZGV2aW5lUHNzaERhdGFIABJVCgt3ZWJtX2tleV9pZBgCIAEoCzI+LnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5XZWJtS2V5SWRIABJgChBleGlzdGluZ19saWNlbnNlGAMgASgLMkQudmlkZW9fd2lkZXZpbmUuTGljZW5zZVJlcXVlc3QuQ29udGVudElkZW50aWZpY2F0aW9uLkV4aXN0aW5nTGljZW5zZUgAElIKCWluaXRfZGF0YRgEIAEoCzI9LnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5Jbml0RGF0YUgAGmwKEFdpZGV2aW5lUHNzaERhdGESEQoJcHNzaF9kYXRhGAEgAygMEjEKDGxpY2Vuc2VfdHlwZRgCIAEoDjIbLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VUeXBlEhIKCnJlcXVlc3RfaWQYAyABKAwaYgoJV2VibUtleUlkEg4KBmhlYWRlchgBIAEoDBIxCgxsaWNlbnNlX3R5cGUYAiABKA4yGy52aWRlb193aWRldmluZS5MaWNlbnNlVHlwZRISCgpyZXF1ZXN0X2lkGAMgASgMGrEBCg9FeGlzdGluZ0xpY2Vuc2USOQoKbGljZW5zZV9pZBgBIAEoCzIlLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VJZGVudGlmaWNhdGlvbhIdChVzZWNvbmRzX3NpbmNlX3N0YXJ0ZWQYAiABKAMSIQoZc2Vjb25kc19zaW5jZV9sYXN0X3BsYXllZBgDIAEoAxIhChlzZXNzaW9uX3VzYWdlX3RhYmxlX2VudHJ5GAQgASgMGvIBCghJbml0RGF0YRJoCg5pbml0X2RhdGFfdHlwZRgBIAEoDjJKLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5Jbml0RGF0YS5Jbml0RGF0YVR5cGU6BENFTkMSEQoJaW5pdF9kYXRhGAIgASgMEjEKDGxpY2Vuc2VfdHlwZRgDIAEoDjIbLnZpZGVvX3dpZGV2aW5lLkxpY2Vuc2VUeXBlEhIKCnJlcXVlc3RfaWQYBCABKAwiIgoMSW5pdERhdGFUeXBlEggKBENFTkMQARIICgRXRUJNEAJCFAoSY29udGVudF9pZF92YXJpYW50IjAKC1JlcXVlc3RUeXBlEgcKA05FVxABEgsKB1JFTkVXQUwQAhILCgdSRUxFQVNFEAMi1QEKDExpY2Vuc2VFcnJvchI2CgplcnJvcl9jb2RlGAEgASgOMiIudmlkZW9fd2lkZXZpbmUuTGljZW5zZUVycm9yLkVycm9yIowBCgVFcnJvchIiCh5JTlZBTElEX0RSTV9ERVZJQ0VfQ0VSVElGSUNBVEUQARIiCh5SRVZPS0VEX0RSTV9ERVZJQ0VfQ0VSVElGSUNBVEUQAhIXChNTRVJWSUNFX1VOQVZBSUxBQkxFEAMSIgoeRVhQSVJFRF9EUk1fREVWSUNFX0NFUlRJRklDQVRFEAQi2QEKCk1ldHJpY0RhdGESEgoKc3RhZ2VfbmFtZRgBIAEoCRI5CgttZXRyaWNfZGF0YRgCIAMoCzIkLnZpZGVvX3dpZGV2aW5lLk1ldHJpY0RhdGEuVHlwZVZhbHVlGlIKCVR5cGVWYWx1ZRIzCgR0eXBlGAEgASgOMiUudmlkZW9fd2lkZXZpbmUuTWV0cmljRGF0YS5NZXRyaWNUeXBlEhAKBXZhbHVlGAIgASgDOgEwIigKCk1ldHJpY1R5cGUSCwoHTEFURU5DWRABEg0KCVRJTUVTVEFNUBACIksKC1ZlcnNpb25JbmZvEhsKE2xpY2Vuc2Vfc2RrX3ZlcnNpb24YASABKAkSHwoXbGljZW5zZV9zZXJ2aWNlX3ZlcnNpb24YAiABKAkivQYKDVNpZ25lZE1lc3NhZ2USNwoEdHlwZRgBIAEoDjIpLnZpZGVvX3dpZGV2aW5lLlNpZ25lZE1lc3NhZ2UuTWVzc2FnZVR5cGUSCwoDbXNnGAIgASgMEhEKCXNpZ25hdHVyZRgDIAEoDBITCgtzZXNzaW9uX2tleRgEIAEoDBI9ChJyZW1vdGVfYXR0ZXN0YXRpb24YBSABKAsyIS52aWRlb193aWRldmluZS5SZW1vdGVBdHRlc3RhdGlvbhIvCgttZXRyaWNfZGF0YRgGIAMoCzIaLnZpZGVvX3dpZGV2aW5lLk1ldHJpY0RhdGESOQoUc2VydmljZV92ZXJzaW9uX2luZm8YByABKAsyGy52aWRlb193aWRldmluZS5WZXJzaW9uSW5mbxJXChBzZXNzaW9uX2tleV90eXBlGAggASgOMiwudmlkZW9fd2lkZXZpbmUuU2lnbmVkTWVzc2FnZS5TZXNzaW9uS2V5VHlwZToPV1JBUFBFRF9BRVNfS0VZEh4KFm9lbWNyeXB0b19jb3JlX21lc3NhZ2UYCSABKAwSOgoOaGFzaF9hbGdvcml0aG0YCiABKA4yIi52aWRlb193aWRldmluZS5IYXNoQWxnb3JpdGhtUHJvdG8SGwoTdXNpbmdfc2Vjb25kYXJ5X2tleRgLIAEoCCLsAQoLTWVzc2FnZVR5cGUSEwoPTElDRU5TRV9SRVFVRVNUEAESCwoHTElDRU5TRRACEhIKDkVSUk9SX1JFU1BPTlNFEAMSHwobU0VSVklDRV9DRVJUSUZJQ0FURV9SRVFVRVNUEAQSFwoTU0VSVklDRV9DRVJUSUZJQ0FURRAFEg8KC1NVQl9MSUNFTlNFEAYSFwoTQ0FTX0xJQ0VOU0VfUkVRVUVTVBAHEg8KC0NBU19MSUNFTlNFEAgSHAoYRVhURVJOQUxfTElDRU5TRV9SRVFVRVNUEAkSFAoQRVhURVJOQUxfTElDRU5TRRAKIlIKDlNlc3Npb25LZXlUeXBlEg0KCVVOREVGSU5FRBAAEhMKD1dSQVBQRURfQUVTX0tFWRABEhwKGEVQSEVNRVJBTF9FQ0NfUFVCTElDX0tFWRACIrABChJQdWJsaWNLZXlUb0NlcnRpZnkSEgoKcHVibGljX2tleRgBIAEoDBI8CghrZXlfdHlwZRgCIAEoDjIqLnZpZGVvX3dpZGV2aW5lLlB1YmxpY0tleVRvQ2VydGlmeS5LZXlUeXBlEhEKCXNpZ25hdHVyZRgDIAEoDCI1CgdLZXlUeXBlEhgKFEtFWV9UWVBFX1VOU1BFQ0lGSUVEEAASBwoDUlNBEAESBwoDRUNDEAIi6AEKE1Byb3Zpc2lvbmluZ09wdGlvbnMSWwoQY2VydGlmaWNhdGVfdHlwZRgBIAEoDjIzLnZpZGVvX3dpZGV2aW5lLlByb3Zpc2lvbmluZ09wdGlvbnMuQ2VydGlmaWNhdGVUeXBlOgxXSURFVklORV9EUk0SHQoVY2VydGlmaWNhdGVfYXV0aG9yaXR5GAIgASgJEhEKCXN5c3RlbV9pZBgDIAEoDSJCCg9DZXJ0aWZpY2F0ZVR5cGUSEAoMV0lERVZJTkVfRFJNEAASCAoEWDUwORABEhMKD1dJREVWSU5FX0tFWUJPWBACIqgGChNQcm92aXNpb25pbmdSZXF1ZXN0EjkKCWNsaWVudF9pZBgBIAEoCzIkLnZpZGVvX3dpZGV2aW5lLkNsaWVudElkZW50aWZpY2F0aW9uSAASTAoTZW5jcnlwdGVkX2NsaWVudF9pZBgFIAEoCzItLnZpZGVvX3dpZGV2aW5lLkVuY3J5cHRlZENsaWVudElkZW50aWZpY2F0aW9uSAASDQoFbm9uY2UYAiABKAwSNAoHb3B0aW9ucxgDIAEoCzIjLnZpZGVvX3dpZGV2aW5lLlByb3Zpc2lvbmluZ09wdGlvbnMSEwoJc3RhYmxlX2lkGAQgASgMSAESFQoLcHJvdmlkZXJfaWQYBiABKAxIARIPCgVzcG9pZBgHIAEoDEgBElgKFmVuY3J5cHRlZF9zZXNzaW9uX2tleXMYCCABKAsyOC52aWRlb193aWRldmluZS5Qcm92aXNpb25pbmdSZXF1ZXN0LkVuY3J5cHRlZFNlc3Npb25LZXlzEmoKGmFuZHJvaWRfb3RhX2tleWJveF9yZXF1ZXN0GAkgASgLMkYudmlkZW9fd2lkZXZpbmUuUHJvdmlzaW9uaW5nUmVxdWVzdC5BbmRyb2lkQXR0ZXN0YXRpb25PdGFLZXlib3hSZXF1ZXN0EkIKFmNlcnRpZmljYXRlX3B1YmxpY19rZXkYCiABKAsyIi52aWRlb193aWRldmluZS5QdWJsaWNLZXlUb0NlcnRpZnkakQEKFEVuY3J5cHRlZFNlc3Npb25LZXlzEiEKGWNlcnRpZmljYXRlX3NlcmlhbF9udW1iZXIYASABKAwSHgoWZW5jcnlwdGVkX3Nlc3Npb25fa2V5cxgCIAEoDBo2CgtTZXNzaW9uS2V5cxIWCg5lbmNyeXB0aW9uX2tleRgBIAEoDBIPCgdtYWNfa2V5GAIgASgMGjkKIkFuZHJvaWRBdHRlc3RhdGlvbk90YUtleWJveFJlcXVlc3QSEwoLb3RhX3JlcXVlc3QYASABKAxCHgocY2xlYXJfb3JfZW5jcnlwdGVkX2NsaWVudF9pZEINCgtzcG9pZF9wYXJhbSKIBQoUUHJvdmlzaW9uaW5nUmVzcG9uc2USFgoOZGV2aWNlX3JzYV9rZXkYASABKAwSGQoRZGV2aWNlX3JzYV9rZXlfaXYYAiABKAwSGgoSZGV2aWNlX2NlcnRpZmljYXRlGAMgASgMEg0KBW5vbmNlGAQgASgMEhQKDHdyYXBwaW5nX2tleRgFIAEoDBJCCgpvdGFfa2V5Ym94GAYgASgLMi4udmlkZW9fd2lkZXZpbmUuUHJvdmlzaW9uaW5nUmVzcG9uc2UuT3RhS2V5Ym94EkcKBnN0YXR1cxgHIAEoDjI3LnZpZGVvX3dpZGV2aW5lLlByb3Zpc2lvbmluZ1Jlc3BvbnNlLlByb3Zpc2lvbmluZ1N0YXR1cxJtChthbmRyb2lkX290YV9rZXlib3hfcmVzcG9uc2UYCCABKAsySC52aWRlb193aWRldmluZS5Qcm92aXNpb25pbmdSZXNwb25zZS5BbmRyb2lkQXR0ZXN0YXRpb25PdGFLZXlib3hSZXNwb25zZRpkCglPdGFLZXlib3gSIAoYZGV2aWNlX2tleV9lbmNyeXB0aW9uX2l2GAEgASgMEhwKFGVuY3J5cHRlZF9kZXZpY2Vfa2V5GAIgASgMEhcKD2RldmljZV9jYV90b2tlbhgDIAEoDBo7CiNBbmRyb2lkQXR0ZXN0YXRpb25PdGFLZXlib3hSZXNwb25zZRIUCgxvdGFfcmVzcG9uc2UYASABKAwiXQoSUHJvdmlzaW9uaW5nU3RhdHVzEgwKCE5PX0VSUk9SEAASHgoaUkVWT0tFRF9ERVZJQ0VfQ1JFREVOVElBTFMQARIZChVSRVZPS0VEX0RFVklDRV9TRVJJRVMQAiI9ChNQcm92aXNpb25pbmdDb250ZXh0EhAKCGtleV9kYXRhGAEgASgMEhQKDGNvbnRleHRfZGF0YRgCIAEoDCKIAQoZU2lnbmVkUHJvdmlzaW9uaW5nQ29udGV4dBIcChRwcm92aXNpb25pbmdfY29udGV4dBgBIAEoDBIRCglzaWduYXR1cmUYAiABKAwSOgoOaGFzaF9hbGdvcml0aG0YAyABKA4yIi52aWRlb193aWRldmluZS5IYXNoQWxnb3JpdGhtUHJvdG8iSwoaUHJvdmlzaW9uaW5nQ29udGV4dEtleURhdGESFgoOZW5jcnlwdGlvbl9rZXkYASABKAwSFQoNZW5jcnlwdGlvbl9pdhgCIAEoDCKfCAoZU2lnbmVkUHJvdmlzaW9uaW5nTWVzc2FnZRIPCgdtZXNzYWdlGAEgASgMEhEKCXNpZ25hdHVyZRgCIAEoDBJmChFwcm92aXNpb25pbmdfdHlwZRgDIAEoDjI6LnZpZGVvX3dpZGV2aW5lLlNpZ25lZFByb3Zpc2lvbmluZ01lc3NhZ2UuUHJvdmlzaW9uaW5nVHlwZToPUFJPVklTSU9OSU5HXzIwEk4KG3NpZ25lZF9wcm92aXNpb25pbmdfY29udGV4dBgEIAEoCzIpLnZpZGVvX3dpZGV2aW5lLlNpZ25lZFByb3Zpc2lvbmluZ0NvbnRleHQSPQoScmVtb3RlX2F0dGVzdGF0aW9uGAUgASgLMiEudmlkZW9fd2lkZXZpbmUuUmVtb3RlQXR0ZXN0YXRpb24SHgoWb2VtY3J5cHRvX2NvcmVfbWVzc2FnZRgGIAEoDBI6Cg5oYXNoX2FsZ29yaXRobRgHIAEoDjIiLnZpZGVvX3dpZGV2aW5lLkhhc2hBbGdvcml0aG1Qcm90bxJfChBwcm90b2NvbF92ZXJzaW9uGAggASgOMkUudmlkZW9fd2lkZXZpbmUuU2lnbmVkUHJvdmlzaW9uaW5nTWVzc2FnZS5Qcm92aXNpb25pbmdQcm90b2NvbFZlcnNpb24SEwoLc2Vzc2lvbl9rZXkYCSABKAwSUgoQc2Vzc2lvbl9rZXlfdHlwZRgKIAEoDjI4LnZpZGVvX3dpZGV2aW5lLlNpZ25lZFByb3Zpc2lvbmluZ01lc3NhZ2UuU2Vzc2lvbktleVR5cGUiVgobUHJvdmlzaW9uaW5nUHJvdG9jb2xWZXJzaW9uEhcKE1ZFUlNJT05fVU5TUEVDSUZJRUQQABINCglWRVJTSU9OXzEQARIPCgtWRVJTSU9OXzFfMRACIpQCChBQcm92aXNpb25pbmdUeXBlEiEKHVBST1ZJU0lPTklOR19UWVBFX1VOU1BFQ0lGSUVEEAASHwobU0VSVklDRV9DRVJUSUZJQ0FURV9SRVFVRVNUEAESEwoPUFJPVklTSU9OSU5HXzIwEAISEwoPUFJPVklTSU9OSU5HXzMwEAMSEwoPUFJPVklTSU9OSU5HXzQwEAUSFgoSQVJDUFBfUFJPVklTSU9OSU5HEAQSIgoeQU5EUk9JRF9BVFRFU1RBVElPTl9LRVlCT1hfT1RBEAYSFgoSRFJNX1JFUFJPVklTSU9OSU5HEAcSEwoPSU5URUxfU0lHTUFfMTAxEGUSFAoPSU5URUxfU0lHTUFfMjEwENIBIlIKDlNlc3Npb25LZXlUeXBlEg0KCVVOREVGSU5FRBAAEhMKD1dSQVBQRURfQUVTX0tFWRABEhwKGEVQSEVNRVJBTF9FQ0NfUFVCTElDX0tFWRACIpMRChRDbGllbnRJZGVudGlmaWNhdGlvbhJECgR0eXBlGAEgASgOMi4udmlkZW9fd2lkZXZpbmUuQ2xpZW50SWRlbnRpZmljYXRpb24uVG9rZW5UeXBlOgZLRVlCT1gSDQoFdG9rZW4YAiABKAwSQwoLY2xpZW50X2luZm8YAyADKAsyLi52aWRlb193aWRldmluZS5DbGllbnRJZGVudGlmaWNhdGlvbi5OYW1lVmFsdWUSHQoVcHJvdmlkZXJfY2xpZW50X3Rva2VuGAQgASgMEhcKD2xpY2Vuc2VfY291bnRlchgFIAEoDRJUChNjbGllbnRfY2FwYWJpbGl0aWVzGAYgASgLMjcudmlkZW9fd2lkZXZpbmUuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q2FwYWJpbGl0aWVzEhAKCHZtcF9kYXRhGAcgASgMElIKEmRldmljZV9jcmVkZW50aWFscxgIIAEoCzI2LnZpZGVvX3dpZGV2aW5lLkNsaWVudElkZW50aWZpY2F0aW9uLkNsaWVudENyZWRlbnRpYWxzGigKCU5hbWVWYWx1ZRIMCgRuYW1lGAEgASgJEg0KBXZhbHVlGAIgASgJGqULChJDbGllbnRDYXBhYmlsaXRpZXMSGwoMY2xpZW50X3Rva2VuGAEgASgIOgVmYWxzZRIcCg1zZXNzaW9uX3Rva2VuGAIgASgIOgVmYWxzZRIrChx2aWRlb19yZXNvbHV0aW9uX2NvbnN0cmFpbnRzGAMgASgIOgVmYWxzZRJoChBtYXhfaGRjcF92ZXJzaW9uGAQgASgOMkMudmlkZW9fd2lkZXZpbmUuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q2FwYWJpbGl0aWVzLkhkY3BWZXJzaW9uOglIRENQX05PTkUSHgoWb2VtX2NyeXB0b19hcGlfdmVyc2lvbhgFIAEoDRIoChlhbnRpX3JvbGxiYWNrX3VzYWdlX3RhYmxlGAYgASgIOgVmYWxzZRITCgtzcm1fdmVyc2lvbhgHIAEoDRIdCg5jYW5fdXBkYXRlX3NybRgIIAEoCDoFZmFsc2UScgoec3VwcG9ydGVkX2NlcnRpZmljYXRlX2tleV90eXBlGAkgAygOMkoudmlkZW9fd2lkZXZpbmUuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q2FwYWJpbGl0aWVzLkNlcnRpZmljYXRlS2V5VHlwZRKLAQoaYW5hbG9nX291dHB1dF9jYXBhYmlsaXRpZXMYCiABKA4yUC52aWRlb193aWRldmluZS5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXMuQW5hbG9nT3V0cHV0Q2FwYWJpbGl0aWVzOhVBTkFMT0dfT1VUUFVUX1VOS05PV04SKAoZY2FuX2Rpc2FibGVfYW5hbG9nX291dHB1dBgLIAEoCDoFZmFsc2USHwoUcmVzb3VyY2VfcmF0aW5nX3RpZXIYDCABKA06ATASaQoUd2F0ZXJtYXJraW5nX3N1cHBvcnQYDSABKA4ySy52aWRlb193aWRldmluZS5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXMuV2F0ZXJtYXJraW5nU3VwcG9ydBIpChppbml0aWFsX3JlbmV3YWxfZGVsYXlfYmFzZRgOIAEoCDoFZmFsc2UiywEKC0hkY3BWZXJzaW9uEg0KCUhEQ1BfTk9ORRAAEgsKB0hEQ1BfVjEQARILCgdIRENQX1YyEAISDQoJSERDUF9WMl8xEAMSDQoJSERDUF9WMl8yEAQSDQoJSERDUF9WMl8zEAUSDQoJSERDUF9WMV8wEAYSDQoJSERDUF9WMV8xEAcSDQoJSERDUF9WMV8yEAgSDQoJSERDUF9WMV8zEAkSDQoJSERDUF9WMV80EAoSGwoWSERDUF9OT19ESUdJVEFMX09VVFBVVBD/ASJpChJDZXJ0aWZpY2F0ZUtleVR5cGUSDAoIUlNBXzIwNDgQABIMCghSU0FfMzA3MhABEhEKDUVDQ19TRUNQMjU2UjEQAhIRCg1FQ0NfU0VDUDM4NFIxEAMSEQoNRUNDX1NFQ1A1MjFSMRAEIo0BChhBbmFsb2dPdXRwdXRDYXBhYmlsaXRpZXMSGQoVQU5BTE9HX09VVFBVVF9VTktOT1dOEAASFgoSQU5BTE9HX09VVFBVVF9OT05FEAESGwoXQU5BTE9HX09VVFBVVF9TVVBQT1JURUQQAhIhCh1BTkFMT0dfT1VUUFVUX1NVUFBPUlRTX0NHTVNfQRADIpIBChNXYXRlcm1hcmtpbmdTdXBwb3J0EiAKHFdBVEVSTUFSS0lOR19TVVBQT1JUX1VOS05PV04QABIeChpXQVRFUk1BUktJTkdfTk9UX1NVUFBPUlRFRBABEh0KGVdBVEVSTUFSS0lOR19DT05GSUdVUkFCTEUQAhIaChZXQVRFUk1BUktJTkdfQUxXQVlTX09OEAMaaAoRQ2xpZW50Q3JlZGVudGlhbHMSRAoEdHlwZRgBIAEoDjIuLnZpZGVvX3dpZGV2aW5lLkNsaWVudElkZW50aWZpY2F0aW9uLlRva2VuVHlwZToGS0VZQk9YEg0KBXRva2VuGAIgASgMIrABCglUb2tlblR5cGUSCgoGS0VZQk9YEAASGgoWRFJNX0RFVklDRV9DRVJUSUZJQ0FURRABEiIKHlJFTU9URV9BVFRFU1RBVElPTl9DRVJUSUZJQ0FURRACEhoKFk9FTV9ERVZJQ0VfQ0VSVElGSUNBVEUQAxIaChZCT09UX0NFUlRJRklDQVRFX0NIQUlOEAQSHwobQk9PVF9DRVJUSUZJQ0FURV9DSEFJTl9YNTA5EAUiuwEKHUVuY3J5cHRlZENsaWVudElkZW50aWZpY2F0aW9uEhMKC3Byb3ZpZGVyX2lkGAEgASgJEikKIXNlcnZpY2VfY2VydGlmaWNhdGVfc2VyaWFsX251bWJlchgCIAEoDBIbChNlbmNyeXB0ZWRfY2xpZW50X2lkGAMgASgMEh4KFmVuY3J5cHRlZF9jbGllbnRfaWRfaXYYBCABKAwSHQoVZW5jcnlwdGVkX3ByaXZhY3lfa2V5GAUgASgMIvsBCg1Sb290T2ZUcnVzdElkEkMKB3ZlcnNpb24YASABKA4yMi52aWRlb193aWRldmluZS5Sb290T2ZUcnVzdElkLlJvb3RPZlRydXN0SWRWZXJzaW9uEg4KBmtleV9pZBgCIAEoDRIbChNlbmNyeXB0ZWRfdW5pcXVlX2lkGAMgASgMEhYKDnVuaXF1ZV9pZF9oYXNoGAQgASgMImAKFFJvb3RPZlRydXN0SWRWZXJzaW9uEigKJFJPT1RfT0ZfVFJVU1RfSURfVkVSU0lPTl9VTlNQRUNJRklFRBAAEh4KGlJPT1RfT0ZfVFJVU1RfSURfVkVSU0lPTl8xEAEirQcKDkRybUNlcnRpZmljYXRlEjEKBHR5cGUYASABKA4yIy52aWRlb193aWRldmluZS5Ecm1DZXJ0aWZpY2F0ZS5UeXBlEhUKDXNlcmlhbF9udW1iZXIYAiABKAwSHQoVY3JlYXRpb25fdGltZV9zZWNvbmRzGAMgASgNEh8KF2V4cGlyYXRpb25fdGltZV9zZWNvbmRzGAwgASgNEhIKCnB1YmxpY19rZXkYBCABKAwSEQoJc3lzdGVtX2lkGAUgASgNEiIKFnRlc3RfZGV2aWNlX2RlcHJlY2F0ZWQYBiABKAhCAhgBEhMKC3Byb3ZpZGVyX2lkGAcgASgJEkEKDXNlcnZpY2VfdHlwZXMYCCADKA4yKi52aWRlb193aWRldmluZS5Ecm1DZXJ0aWZpY2F0ZS5TZXJ2aWNlVHlwZRJACglhbGdvcml0aG0YCSABKA4yKC52aWRlb193aWRldmluZS5Ecm1DZXJ0aWZpY2F0ZS5BbGdvcml0aG06A1JTQRItCgZyb3RfaWQYCiABKAsyHS52aWRlb193aWRldmluZS5Sb290T2ZUcnVzdElkEkQKDmVuY3J5cHRpb25fa2V5GAsgASgLMiwudmlkZW9fd2lkZXZpbmUuRHJtQ2VydGlmaWNhdGUuRW5jcnlwdGlvbktleRplCg1FbmNyeXB0aW9uS2V5EhIKCnB1YmxpY19rZXkYASABKAwSQAoJYWxnb3JpdGhtGAIgASgOMigudmlkZW9fd2lkZXZpbmUuRHJtQ2VydGlmaWNhdGUuQWxnb3JpdGhtOgNSU0EiYQoEVHlwZRIICgRST09UEAASEAoMREVWSUNFX01PREVMEAESCgoGREVWSUNFEAISCwoHU0VSVklDRRADEg8KC1BST1ZJU0lPTkVSEAQSEwoPREVWSUNFX0VNQkVEREVEEAUihgEKC1NlcnZpY2VUeXBlEhgKFFVOS05PV05fU0VSVklDRV9UWVBFEAASFgoSTElDRU5TRV9TRVJWRVJfU0RLEAESHAoYTElDRU5TRV9TRVJWRVJfUFJPWFlfU0RLEAISFAoQUFJPVklTSU9OSU5HX1NESxADEhEKDUNBU19QUk9YWV9TREsQBCJkCglBbGdvcml0aG0SFQoRVU5LTk9XTl9BTEdPUklUSE0QABIHCgNSU0EQARIRCg1FQ0NfU0VDUDI1NlIxEAISEQoNRUNDX1NFQ1AzODRSMRADEhEKDUVDQ19TRUNQNTIxUjEQBCK0AQoUU2lnbmVkRHJtQ2VydGlmaWNhdGUSFwoPZHJtX2NlcnRpZmljYXRlGAEgASgMEhEKCXNpZ25hdHVyZRgCIAEoDBI0CgZzaWduZXIYAyABKAsyJC52aWRlb193aWRldmluZS5TaWduZWREcm1DZXJ0aWZpY2F0ZRI6Cg5oYXNoX2FsZ29yaXRobRgEIAEoDjIiLnZpZGVvX3dpZGV2aW5lLkhhc2hBbGdvcml0aG1Qcm90byKIBgoQV2lkZXZpbmVQc3NoRGF0YRIPCgdrZXlfaWRzGAIgAygMEhIKCmNvbnRlbnRfaWQYBCABKAwSGwoTY3J5cHRvX3BlcmlvZF9pbmRleBgHIAEoDRIZChFwcm90ZWN0aW9uX3NjaGVtZRgJIAEoDRIdChVjcnlwdG9fcGVyaW9kX3NlY29uZHMYCiABKA0SOwoEdHlwZRgLIAEoDjIlLnZpZGVvX3dpZGV2aW5lLldpZGV2aW5lUHNzaERhdGEuVHlwZToGU0lOR0xFEhQKDGtleV9zZXF1ZW5jZRgMIAEoDRIRCglncm91cF9pZHMYDSADKAwSQwoNZW50aXRsZWRfa2V5cxgOIAMoCzIsLnZpZGVvX3dpZGV2aW5lLldpZGV2aW5lUHNzaERhdGEuRW50aXRsZWRLZXkSFQoNdmlkZW9fZmVhdHVyZRgPIAEoCRIVCg1hdWRpb19mZWF0dXJlGBAgASgJEiAKGGVudGl0bGVtZW50X3BlcmlvZF9pbmRleBgRIAEoDRJBCglhbGdvcml0aG0YASABKA4yKi52aWRlb193aWRldmluZS5XaWRldmluZVBzc2hEYXRhLkFsZ29yaXRobUICGAESFAoIcHJvdmlkZXIYAyABKAlCAhgBEhYKCnRyYWNrX3R5cGUYBSABKAlCAhgBEhIKBnBvbGljeRgGIAEoCUICGAESGwoPZ3JvdXBlZF9saWNlbnNlGAggASgMQgIYARp6CgtFbnRpdGxlZEtleRIaChJlbnRpdGxlbWVudF9rZXlfaWQYASABKAwSDgoGa2V5X2lkGAIgASgMEgsKA2tleRgDIAEoDBIKCgJpdhgEIAEoDBImChplbnRpdGxlbWVudF9rZXlfc2l6ZV9ieXRlcxgFIAEoDToCMzIiNQoEVHlwZRIKCgZTSU5HTEUQABIPCgtFTlRJVExFTUVOVBABEhAKDEVOVElUTEVEX0tFWRACIigKCUFsZ29yaXRobRIPCgtVTkVOQ1JZUFRFRBAAEgoKBkFFU0NUUhABKjgKC0xpY2Vuc2VUeXBlEg0KCVNUUkVBTUlORxABEgsKB09GRkxJTkUQAhINCglBVVRPTUFUSUMQAyrZAQoaUGxhdGZvcm1WZXJpZmljYXRpb25TdGF0dXMSFwoTUExBVEZPUk1fVU5WRVJJRklFRBAAEhUKEVBMQVRGT1JNX1RBTVBFUkVEEAESHgoaUExBVEZPUk1fU09GVFdBUkVfVkVSSUZJRUQQAhIeChpQTEFURk9STV9IQVJEV0FSRV9WRVJJRklFRBADEhwKGFBMQVRGT1JNX05PX1ZFUklGSUNBVElPThAEEi0KKVBMQVRGT1JNX1NFQ1VSRV9TVE9SQUdFX1NPRlRXQVJFX1ZFUklGSUVEEAUqRAoPUHJvdG9jb2xWZXJzaW9uEg8KC1ZFUlNJT05fMl8wEBQSDwoLVkVSU0lPTl8yXzEQFRIPCgtWRVJTSU9OXzJfMhAWKoYBChJIYXNoQWxnb3JpdGhtUHJvdG8SHgoaSEFTSF9BTEdPUklUSE1fVU5TUEVDSUZJRUQQABIYChRIQVNIX0FMR09SSVRITV9TSEFfMRABEhoKFkhBU0hfQUxHT1JJVEhNX1NIQV8yNTYQAhIaChZIQVNIX0FMR09SSVRITV9TSEFfMzg0EANCJAogY29tLmdvb2dsZS52aWRlby53aWRldmluZS5wcm90b3NIAw'
    )

/**
 * @generated from message video_widevine.RemoteAttestation
 */
export type RemoteAttestation = Message<'video_widevine.RemoteAttestation'> & {
    /**
     * Encrypted ClientIdentification message containing the device remote
     * attestation certificate. Required.
     *
     * @generated from field: optional video_widevine.EncryptedClientIdentification certificate = 1;
     */
    certificate?: EncryptedClientIdentification

    /**
     * Bytes of salt which were added to the remote attestation challenge prior to
     * signing it. Required.
     *
     * @generated from field: optional bytes salt = 2;
     */
    salt: Uint8Array

    /**
     * Signed remote attestation challenge + salt. Required.
     *
     * @generated from field: optional bytes signature = 3;
     */
    signature: Uint8Array
}

/**
 * Describes the message video_widevine.RemoteAttestation.
 * Use `create(RemoteAttestationSchema)` to create a new message.
 */
export const RemoteAttestationSchema: GenMessage<RemoteAttestation> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 0)

/**
 * @generated from message video_widevine.DTCPUsageRules
 */
export type DTCPUsageRules = Message<'video_widevine.DTCPUsageRules'> & {
    /**
     * Indicates if Digital Transmission Control Protection 2 (DTCP2) is required.
     *
     * @generated from field: optional bool require_dtcp2 = 1 [default = false];
     */
    requireDtcp2: boolean

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.CopyControlInfo copy_control = 2;
     */
    copyControl: DTCPUsageRules_CopyControlInfo

    /**
     * @generated from field: optional bool encryption_plus = 3;
     */
    encryptionPlus: boolean

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.RetentionState retention_state = 4;
     */
    retentionState: DTCPUsageRules_RetentionState

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.AnalogProtectionSystem analog_protection_system = 5;
     */
    analogProtectionSystem: DTCPUsageRules_AnalogProtectionSystem

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.ImageConstraintToken image_constraint_token = 6;
     */
    imageConstraintToken: DTCPUsageRules_ImageConstraintToken

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.AnalogSunsetToken analog_sunset_token = 7;
     */
    analogSunsetToken: DTCPUsageRules_AnalogSunsetToken

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.DigitalOnlyToken digital_only_token = 8;
     */
    digitalOnlyToken: DTCPUsageRules_DigitalOnlyToken

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.AudioEnhancedToken audio_enhanced_token = 9;
     */
    audioEnhancedToken: DTCPUsageRules_AudioEnhancedToken

    /**
     * @generated from field: optional uint32 copy_count = 10;
     */
    copyCount: number

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.StandardDigitalOutputToken standard_digital_token = 11;
     */
    standardDigitalToken: DTCPUsageRules_StandardDigitalOutputToken

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.HighDynamicRangeToken high_dynamic_token = 12;
     */
    highDynamicToken: DTCPUsageRules_HighDynamicRangeToken

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.L2ProtectionOnlyToken l2_only_token = 13;
     */
    l2OnlyToken: DTCPUsageRules_L2ProtectionOnlyToken

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.EnhancedImageToken enhaned_image_token = 14;
     */
    enhanedImageToken: DTCPUsageRules_EnhancedImageToken

    /**
     * @generated from field: optional uint32 retention_time = 15;
     */
    retentionTime: number

    /**
     * @generated from field: optional video_widevine.DTCPUsageRules.FurtherBoundCopy further_copy = 16;
     */
    furtherCopy: DTCPUsageRules_FurtherBoundCopy
}

/**
 * Describes the message video_widevine.DTCPUsageRules.
 * Use `create(DTCPUsageRulesSchema)` to create a new message.
 */
export const DTCPUsageRulesSchema: GenMessage<DTCPUsageRules> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 1)

/**
 * This field indicates the value of Retention_State.
 *
 * @generated from enum video_widevine.DTCPUsageRules.RetentionState
 */
export enum DTCPUsageRules_RetentionState {
    /**
     * (-- api-linter: core::0126::unspecified=disabled
     *     aip.dev/not-precedent: name and values are defined in the DTCP
     *     specification. --)
     * Forever
     *
     * @generated from enum value: RETENTION_STATE_FOREVER = 0;
     */
    RETENTION_STATE_FOREVER = 0,

    /**
     * 1 week
     *
     * @generated from enum value: RETENTION_STATE_1_WEEK = 1;
     */
    RETENTION_STATE_1_WEEK = 1,

    /**
     * 2 day
     *
     * @generated from enum value: RETENTION_STATE_2_DAYS = 2;
     */
    RETENTION_STATE_2_DAYS = 2,

    /**
     * 1 day
     *
     * @generated from enum value: RETENTION_STATE_1_DAY = 3;
     */
    RETENTION_STATE_1_DAY = 3,

    /**
     * 12 hours
     *
     * @generated from enum value: RETENTION_STATE_12_HOURS = 4;
     */
    RETENTION_STATE_12_HOURS = 4,

    /**
     * 6 hours
     *
     * @generated from enum value: RETENTION_STATE_6_HOURS = 5;
     */
    RETENTION_STATE_6_HOURS = 5,

    /**
     * 3 hours
     *
     * @generated from enum value: RETENTION_STATE_3_HOURS = 6;
     */
    RETENTION_STATE_3_HOURS = 6,

    /**
     * 90 minutes
     *
     * @generated from enum value: RETENTION_STATE_90_MINUTES = 7;
     */
    RETENTION_STATE_90_MINUTES = 7
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.RetentionState.
 */
export const DTCPUsageRules_RetentionStateSchema: GenEnum<DTCPUsageRules_RetentionState> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 0)

/**
 * This field indicates Copy Control Information (CCI).
 *
 * @generated from enum video_widevine.DTCPUsageRules.CopyControlInfo
 */
export enum DTCPUsageRules_CopyControlInfo {
    /**
     * Copy freely
     *
     * @generated from enum value: COPY_FREE = 0;
     */
    COPY_FREE = 0,

    /**
     * No more copies
     *
     * @generated from enum value: COPY_NO_MORE = 1;
     */
    COPY_NO_MORE = 1,

    /**
     * One time copy
     *
     * @generated from enum value: COPY_ONE = 2;
     */
    COPY_ONE = 2,

    /**
     * Copy not allowed
     *
     * @generated from enum value: COPY_NEVER = 3;
     */
    COPY_NEVER = 3
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.CopyControlInfo.
 */
export const DTCPUsageRules_CopyControlInfoSchema: GenEnum<DTCPUsageRules_CopyControlInfo> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 1)

/**
 * This field indicates Analog Protection System (APS) used to block
 * recording devices.
 *
 * @generated from enum video_widevine.DTCPUsageRules.AnalogProtectionSystem
 */
export enum DTCPUsageRules_AnalogProtectionSystem {
    /**
     * Copy freely, APS is off
     *
     * @generated from enum value: APS_OFF = 0;
     */
    APS_OFF = 0,

    /**
     * APS is on, Type 1 (AGC)
     *
     * @generated from enum value: APS_TYPE1 = 1;
     */
    APS_TYPE1 = 1,

    /**
     * APS is on, Type 2 (AGC + 2L Colorstripe)
     *
     * @generated from enum value: APS_TYPE2 = 2;
     */
    APS_TYPE2 = 2,

    /**
     * APS is on, Type 3 (AGC + 4L Colorstripe)
     *
     * @generated from enum value: APS_TYPE3 = 3;
     */
    APS_TYPE3 = 3
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.AnalogProtectionSystem.
 */
export const DTCPUsageRules_AnalogProtectionSystemSchema: GenEnum<DTCPUsageRules_AnalogProtectionSystem> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 2)

/**
 * This field indicates the value of the Image Constraint Token (ICT) that
 * controls downsampling of high-definition video.
 *
 * @generated from enum video_widevine.DTCPUsageRules.ImageConstraintToken
 */
export enum DTCPUsageRules_ImageConstraintToken {
    /**
     * HD analog output, Constrained Image
     *
     * @generated from enum value: ICT_CONSTRAINED = 0;
     */
    ICT_CONSTRAINED = 0,

    /**
     *  HD analog out
     *
     * @generated from enum value: ICT_HD_ANALOG = 1;
     */
    ICT_HD_ANALOG = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.ImageConstraintToken.
 */
export const DTCPUsageRules_ImageConstraintTokenSchema: GenEnum<DTCPUsageRules_ImageConstraintToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 3)

/**
 * This field indicates the value of Analog Sunset Token (AST) used to limit
 * playback to standard definition (SD) only
 *
 * @generated from enum video_widevine.DTCPUsageRules.AnalogSunsetToken
 */
export enum DTCPUsageRules_AnalogSunsetToken {
    /**
     * Asserted
     *
     * @generated from enum value: AST_ASSERTED = 0;
     */
    AST_ASSERTED = 0,

    /**
     * Unasserted
     *
     * @generated from enum value: AST_UNASERTED = 1;
     */
    AST_UNASERTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.AnalogSunsetToken.
 */
export const DTCPUsageRules_AnalogSunsetTokenSchema: GenEnum<DTCPUsageRules_AnalogSunsetToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 4)

/**
 * This field indicates the value of Digital Only Token (DOT) used to restrict
 * output to digital only.
 *
 * @generated from enum video_widevine.DTCPUsageRules.DigitalOnlyToken
 */
export enum DTCPUsageRules_DigitalOnlyToken {
    /**
     * Asserted
     *
     * @generated from enum value: DOT_ASSERTED = 0;
     */
    DOT_ASSERTED = 0,

    /**
     * Unasserted
     *
     * @generated from enum value: DOT_UNASSERTED = 1;
     */
    DOT_UNASSERTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.DigitalOnlyToken.
 */
export const DTCPUsageRules_DigitalOnlyTokenSchema: GenEnum<DTCPUsageRules_DigitalOnlyToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 5)

/**
 * This field indicates the value of Audio Enhanced Token (AET).
 *
 * @generated from enum video_widevine.DTCPUsageRules.AudioEnhancedToken
 */
export enum DTCPUsageRules_AudioEnhancedToken {
    /**
     * Asserted
     *
     * @generated from enum value: AET_ASSERTED = 0;
     */
    AET_ASSERTED = 0,

    /**
     * Unasserted
     *
     * @generated from enum value: AET_UNASSERTED = 1;
     */
    AET_UNASSERTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.AudioEnhancedToken.
 */
export const DTCPUsageRules_AudioEnhancedTokenSchema: GenEnum<DTCPUsageRules_AudioEnhancedToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 6)

/**
 * This field indicates the value of Standard Digital Output (SDO) token.
 *
 * @generated from enum video_widevine.DTCPUsageRules.StandardDigitalOutputToken
 */
export enum DTCPUsageRules_StandardDigitalOutputToken {
    /**
     * Unasserted
     *
     * @generated from enum value: SDO_UNASSEERTED = 0;
     */
    SDO_UNASSEERTED = 0,

    /**
     * Asserted, L2 protection is permitted
     *
     * @generated from enum value: SDO_ASSEERTED = 1;
     */
    SDO_ASSEERTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.StandardDigitalOutputToken.
 */
export const DTCPUsageRules_StandardDigitalOutputTokenSchema: GenEnum<DTCPUsageRules_StandardDigitalOutputToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 7)

/**
 * This field indicates the value of High Dynamic Rnage (HDR) token.
 *
 * @generated from enum video_widevine.DTCPUsageRules.HighDynamicRangeToken
 */
export enum DTCPUsageRules_HighDynamicRangeToken {
    /**
     * Unasserted, SDR conversion is permitted
     *
     * @generated from enum value: HDR_UNASSERTED = 0;
     */
    HDR_UNASSERTED = 0,

    /**
     * Unasserted, SDR conversion is not permitted
     *
     * @generated from enum value: HDR_ASSERTED = 1;
     */
    HDR_ASSERTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.HighDynamicRangeToken.
 */
export const DTCPUsageRules_HighDynamicRangeTokenSchema: GenEnum<DTCPUsageRules_HighDynamicRangeToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 8)

/**
 * This field indicates the value of the L2 Protection Only token.
 *
 * @generated from enum video_widevine.DTCPUsageRules.L2ProtectionOnlyToken
 */
export enum DTCPUsageRules_L2ProtectionOnlyToken {
    /**
     * Unasserted
     *
     * @generated from enum value: L2_ONLY_UNASSERTED = 0;
     */
    L2_ONLY_UNASSERTED = 0,

    /**
     * Aasserted (L2 protection onl)
     *
     * @generated from enum value: L2_ONLY_ASSERTED = 1;
     */
    L2_ONLY_ASSERTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.L2ProtectionOnlyToken.
 */
export const DTCPUsageRules_L2ProtectionOnlyTokenSchema: GenEnum<DTCPUsageRules_L2ProtectionOnlyToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 9)

/**
 * This field indicates the value of the Enhanced Image (EI) token
 *
 * @generated from enum video_widevine.DTCPUsageRules.EnhancedImageToken
 */
export enum DTCPUsageRules_EnhancedImageToken {
    /**
     * Unasserted, Non-Enhanced Image
     *
     * @generated from enum value: EI_UNASSERTED = 0;
     */
    EI_UNASSERTED = 0,

    /**
     * Asserted, Enhanced Image
     *
     * @generated from enum value: EI_ASSERTED = 1;
     */
    EI_ASSERTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.EnhancedImageToken.
 */
export const DTCPUsageRules_EnhancedImageTokenSchema: GenEnum<DTCPUsageRules_EnhancedImageToken> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 10)

/**
 * This field indicates whether a further Bound Copy can be made from a
 * Bound Copy retained in accordance with the RetentionStatefield.
 *
 * @generated from enum video_widevine.DTCPUsageRules.FurtherBoundCopy
 */
export enum DTCPUsageRules_FurtherBoundCopy {
    /**
     * Further Bound Copy Prohibited
     *
     * @generated from enum value: FBC_PROHIBITED = 0;
     */
    FBC_PROHIBITED = 0,

    /**
     * Further Bound Copy Permitted
     *
     * @generated from enum value: FBC_PERMITTED = 1;
     */
    FBC_PERMITTED = 1
}

/**
 * Describes the enum video_widevine.DTCPUsageRules.FurtherBoundCopy.
 */
export const DTCPUsageRules_FurtherBoundCopySchema: GenEnum<DTCPUsageRules_FurtherBoundCopy> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1, 11)

/**
 * LicenseIdentification is propagated from LicenseRequest to License,
 * incrementing version with each iteration.
 *
 * @generated from message video_widevine.LicenseIdentification
 */
export type LicenseIdentification =
    Message<'video_widevine.LicenseIdentification'> & {
        /**
         * @generated from field: optional bytes request_id = 1;
         */
        requestId: Uint8Array

        /**
         * @generated from field: optional bytes session_id = 2;
         */
        sessionId: Uint8Array

        /**
         * @generated from field: optional bytes purchase_id = 3;
         */
        purchaseId: Uint8Array

        /**
         * @generated from field: optional video_widevine.LicenseType type = 4;
         */
        type: LicenseType

        /**
         * @generated from field: optional int32 version = 5;
         */
        version: number

        /**
         * @generated from field: optional bytes provider_session_token = 6;
         */
        providerSessionToken: Uint8Array

        /**
         * Set by the SDK representing the rental duration from the initial license.
         *
         * @generated from field: optional int64 original_rental_duration_seconds = 7;
         */
        originalRentalDurationSeconds: bigint

        /**
         * Set by the SDK representing the playback duration from the initial license.
         *
         * @generated from field: optional int64 original_playback_duration_seconds = 8;
         */
        originalPlaybackDurationSeconds: bigint

        /**
         * Set by the SDK representing the start time of the initial license in
         * seconds (UTC). This is from the original license's license_start_time,
         * which is from the LicenseRequest.request_time when set, or set by the
         * server to be the time that the original license was processed.
         *
         * @generated from field: optional int64 original_start_time_seconds = 9;
         */
        originalStartTimeSeconds: bigint

        /**
         * Set by the SDK representing the renewal recovery duration from the initial
         * license.
         *
         * @generated from field: optional int64 original_renewal_recovery_duration_seconds = 10;
         */
        originalRenewalRecoveryDurationSeconds: bigint

        /**
         * Set by the SDK representing the renewal delay seconds from the original
         * license.
         *
         * @generated from field: optional int64 original_renewal_delay_seconds = 11;
         */
        originalRenewalDelaySeconds: bigint
    }

/**
 * Describes the message video_widevine.LicenseIdentification.
 * Use `create(LicenseIdentificationSchema)` to create a new message.
 */
export const LicenseIdentificationSchema: GenMessage<LicenseIdentification> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 2)

/**
 * This message is used to indicate the license cateogry spec for a license as
 * a part of initial license issuance.
 *
 * @generated from message video_widevine.LicenseCategorySpec
 */
export type LicenseCategorySpec =
    Message<'video_widevine.LicenseCategorySpec'> & {
        /**
         * Optional. License category indicates if license is used for single
         * content, multiple contents (could be a combination of
         * single contents and groups of contents) or a group of contents.
         *
         * @generated from field: optional video_widevine.LicenseCategorySpec.LicenseCategory license_category = 1;
         */
        licenseCategory: LicenseCategorySpec_LicenseCategory

        /**
         * Optional. Content or group ID covered by the license.
         *
         * @generated from oneof video_widevine.LicenseCategorySpec.content_or_group_id
         */
        contentOrGroupId:
            | {
                  /**
                   * Content_id would be present if it is a license for single content.
                   *
                   * @generated from field: bytes content_id = 2;
                   */
                  value: Uint8Array
                  case: 'contentId'
              }
            | {
                  /**
                   * Group_id would be present if the license is a multi_content_license or
                   * group_license. Group Id could be the name of a group of contents,
                   * defined by licensor.
                   *
                   * @generated from field: bytes group_id = 3;
                   */
                  value: Uint8Array
                  case: 'groupId'
              }
            | { case: undefined; value?: undefined }
    }

/**
 * Describes the message video_widevine.LicenseCategorySpec.
 * Use `create(LicenseCategorySpecSchema)` to create a new message.
 */
export const LicenseCategorySpecSchema: GenMessage<LicenseCategorySpec> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 3)

/**
 * Possible license categories.
 *
 * @generated from enum video_widevine.LicenseCategorySpec.LicenseCategory
 */
export enum LicenseCategorySpec_LicenseCategory {
    /**
     * By default, License is used for single content.
     *
     * @generated from enum value: SINGLE_CONTENT_LICENSE_DEFAULT = 0;
     */
    SINGLE_CONTENT_LICENSE_DEFAULT = 0,

    /**
     * License is used for multiple contents (could be a combination of
     * single contents and groups of contents).
     *
     * @generated from enum value: MULTI_CONTENT_LICENSE = 1;
     */
    MULTI_CONTENT_LICENSE = 1,

    /**
     * License is used for contents logically grouped.
     *
     * @generated from enum value: GROUP_LICENSE = 2;
     */
    GROUP_LICENSE = 2
}

/**
 * Describes the enum video_widevine.LicenseCategorySpec.LicenseCategory.
 */
export const LicenseCategorySpec_LicenseCategorySchema: GenEnum<LicenseCategorySpec_LicenseCategory> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 3, 0)

/**
 * @generated from message video_widevine.ProxyInfo
 */
export type ProxyInfo = Message<'video_widevine.ProxyInfo'> & {
    /**
     * Indicates SDK type(Including UNKNOWN_SERVICE_TYPE, LICENSE_PROXY_SDK,
     * CAS_PROXY_SDK).
     *
     * @generated from field: optional video_widevine.DrmCertificate.ServiceType sdk_type = 1;
     */
    sdkType: DrmCertificate_ServiceType

    /**
     * Indicates the version of SDK.
     *
     * @generated from field: optional string sdk_version = 2;
     */
    sdkVersion: string
}

/**
 * Describes the message video_widevine.ProxyInfo.
 * Use `create(ProxyInfoSchema)` to create a new message.
 */
export const ProxyInfoSchema: GenMessage<ProxyInfo> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 4)

/**
 * @generated from message video_widevine.License
 */
export type License = Message<'video_widevine.License'> & {
    /**
     * @generated from field: optional video_widevine.LicenseIdentification id = 1;
     */
    id?: LicenseIdentification

    /**
     * @generated from field: optional video_widevine.License.Policy policy = 2;
     */
    policy?: License_Policy

    /**
     * @generated from field: repeated video_widevine.License.KeyContainer key = 3;
     */
    key: License_KeyContainer[]

    /**
     * Time of the request in seconds (UTC) as set in
     * LicenseRequest.request_time.  If this time is not set in the request,
     * the local time at the license service is used in this field.
     *
     * @generated from field: optional int64 license_start_time = 4;
     */
    licenseStartTime: bigint

    /**
     * Deprecate remote_attestation_verified in favor of
     * platform_verification_status, below.
     *
     * @generated from field: optional bool remote_attestation_verified = 5 [default = false];
     */
    remoteAttestationVerified: boolean

    /**
     * Client token generated by the content provider. Optional.
     *
     * @generated from field: optional bytes provider_client_token = 6;
     */
    providerClientToken: Uint8Array

    /**
     * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
     * specification. Propagated from Widevine PSSH box. Optional.
     *
     * @generated from field: optional uint32 protection_scheme = 7;
     */
    protectionScheme: number

    /**
     * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
     * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
     * depends on client max_hdcp_version).
     *
     * @generated from field: optional bytes srm_requirement = 8;
     */
    srmRequirement: Uint8Array

    /**
     * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
     * depending on client max_hdcp_version) that should be installed on the
     * client device.
     *
     * @generated from field: optional bytes srm_update = 9;
     */
    srmUpdate: Uint8Array

    /**
     * Indicates the status of any type of platform verification performed by the
     * server.
     *
     * @generated from field: optional video_widevine.PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];
     */
    platformVerificationStatus: PlatformVerificationStatus

    /**
     * IDs of the groups for which keys are delivered in this license, if any.
     *
     * @generated from field: repeated bytes group_ids = 11;
     */
    groupIds: Uint8Array[]

    /**
     * Optional. LicenseCategorySpec is used to indicate the license cateogry for
     * a license. It could be used as a part of initial license issuance or shown
     * as a part of license in license response.
     *
     * @generated from field: optional video_widevine.LicenseCategorySpec license_category_spec = 12;
     */
    licenseCategorySpec?: LicenseCategorySpec

    /**
     * Optional: The provider key id indicates which provider key was used
     * during provider key encryption.
     *
     * @generated from field: optional uint32 provider_key_id = 13;
     */
    providerKeyId: number
}

/**
 * Describes the message video_widevine.License.
 * Use `create(LicenseSchema)` to create a new message.
 */
export const LicenseSchema: GenMessage<License> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5)

/**
 * @generated from message video_widevine.License.Policy
 */
export type License_Policy = Message<'video_widevine.License.Policy'> & {
    /**
     * Indicates that playback of the content is allowed.
     *
     * @generated from field: optional bool can_play = 1 [default = false];
     */
    canPlay: boolean

    /**
     * Indicates that the license may be persisted to non-volatile
     * storage for offline use.
     *
     * @generated from field: optional bool can_persist = 2 [default = false];
     */
    canPersist: boolean

    /**
     * Indicates that renewal of this license is allowed.
     *
     * @generated from field: optional bool can_renew = 3 [default = false];
     */
    canRenew: boolean

    /**
     * Indicates the rental window.
     *
     * @generated from field: optional int64 rental_duration_seconds = 4 [default = 0];
     */
    rentalDurationSeconds: bigint

    /**
     * Indicates the viewing window, once playback has begun.
     *
     * @generated from field: optional int64 playback_duration_seconds = 5 [default = 0];
     */
    playbackDurationSeconds: bigint

    /**
     * Indicates the time window for this specific license.
     *
     * @generated from field: optional int64 license_duration_seconds = 6 [default = 0];
     */
    licenseDurationSeconds: bigint

    /**
     * The window of time, in which playback is allowed to continue while
     * renewal is attempted, yet unsuccessful due to backend problems with
     * the license server.
     *
     * @generated from field: optional int64 renewal_recovery_duration_seconds = 7 [default = 0];
     */
    renewalRecoveryDurationSeconds: bigint

    /**
     * All renewal requests for this license shall be directed to the
     * specified URL.
     *
     * @generated from field: optional string renewal_server_url = 8;
     */
    renewalServerUrl: string

    /**
     * How many seconds after the "renewal delay base" before renewal is first
     * attempted. For an initial license, see comments on
     * |initial_renewal_delay_base| on how the "renewal delay base" is
     * determined. For a renewal license, the "renewal delay base" is always the
     * |license_start_time| of the renewal license.
     * NOTE:
     * - Renewal should not be attempted if |can_renew| or |can_play| is false,
     * or if the license has expired.
     * - When the "renewal delay base" is first time of decryption
     * (|FIRST_DECRYPT|), this delay is optional: the client can attempt the
     * renewal without the delay.
     *
     * @generated from field: optional int64 renewal_delay_seconds = 9 [default = 0];
     */
    renewalDelaySeconds: bigint

    /**
     * Specifies the delay in seconds between subsequent license
     * renewal requests, in case of failure.
     *
     * @generated from field: optional int64 renewal_retry_interval_seconds = 10 [default = 0];
     */
    renewalRetryIntervalSeconds: bigint

    /**
     * Indicates that the license shall be sent for renewal when usage is
     * started, i.e. on first playback. This should only be used for a new
     * license. The client shall ignore this if set in a renewal.
     *
     * @generated from field: optional bool renew_with_usage = 11 [default = false];
     */
    renewWithUsage: boolean

    /**
     * Indicates to client that license renewal and release requests ought to
     * include ClientIdentification (client_id).
     *
     * @generated from field: optional bool always_include_client_id = 12 [default = false];
     */
    alwaysIncludeClientId: boolean

    /**
     * Duration of grace period before playback_duration_seconds (short window)
     * goes into effect. Optional.
     * Deprecated in V16.
     *
     * @generated from field: optional int64 play_start_grace_period_seconds = 13 [default = 0];
     */
    playStartGracePeriodSeconds: bigint

    /**
     * Enables "soft enforcement" of playback_duration_seconds, letting the user
     * finish playback even if playback window expires. Optional.
     *
     * @generated from field: optional bool soft_enforce_playback_duration = 14 [default = false];
     */
    softEnforcePlaybackDuration: boolean

    /**
     * Enables "soft enforcement" of rental_duration_seconds. Initial playback
     * must always start before rental duration expires.  In order to allow
     * subsequent playbacks to start after the rental duration expires,
     * soft_enforce_playback_duration must be true. Otherwise, subsequent
     * playbacks will not be allowed once rental duration expires. Optional.
     *
     * @generated from field: optional bool soft_enforce_rental_duration = 15 [default = true];
     */
    softEnforceRentalDuration: boolean

    /**
     * Optional requirement to indicate watermarking is allowed.
     *
     * @generated from field: optional video_widevine.License.Policy.WatermarkingControl watermarking_control = 16 [default = WATERMARKING_CONTROL_UNSPECIFIED];
     */
    watermarkingControl: License_Policy_WatermarkingControl

    /**
     * Optional DTCP2 requirements. Default is to not allow dtcp2.
     *
     * @generated from field: optional video_widevine.DTCPUsageRules dtcp2 = 17;
     */
    dtcp2?: DTCPUsageRules

    /**
     * The base for |renewal_delay_seconds| for the initial license. For renewal
     * licenses this field will be ignored and |renewal_delay_seconds| is always
     * be based on |license_start_time|.
     * NOTE: For backward compatibility, when set to
     * TIMER_DELAY_BASE_UNSPECIFIED or has no value, the actual "renewal delay
     * base" will be FIRST_DECRYPT if |renew_with_usage| is true, or
     * LICENSE_START otherwise.
     *
     * @generated from field: optional video_widevine.License.Policy.TimerDelayBase initial_renewal_delay_base = 18 [default = TIMER_DELAY_BASE_UNSPECIFIED];
     */
    initialRenewalDelayBase: License_Policy_TimerDelayBase
}

/**
 * Describes the message video_widevine.License.Policy.
 * Use `create(License_PolicySchema)` to create a new message.
 */
export const License_PolicySchema: GenMessage<License_Policy> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5, 0)

/**
 * Client-side watermarking restrictions for the license.
 *
 * @generated from enum video_widevine.License.Policy.WatermarkingControl
 */
export enum License_Policy_WatermarkingControl {
    /**
     * Watermarking may or may not be used, provider does not care.
     *
     * @generated from enum value: WATERMARKING_CONTROL_UNSPECIFIED = 0;
     */
    WATERMARKING_CONTROL_UNSPECIFIED = 0,

    /**
     * Watermarking must not be used. The device must disable watermarking
     * if it supports it.
     *
     * @generated from enum value: WATERMARKING_FORBIDDEN = 1;
     */
    WATERMARKING_FORBIDDEN = 1,

    /**
     * Watermarking is required if the device supports it.
     *
     * @generated from enum value: WATERMARKING_REQUIRED = 2;
     */
    WATERMARKING_REQUIRED = 2
}

/**
 * Describes the enum video_widevine.License.Policy.WatermarkingControl.
 */
export const License_Policy_WatermarkingControlSchema: GenEnum<License_Policy_WatermarkingControl> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 0, 0)

/**
 * The base for (delayed) timers, i.e. the time from which the delayed timer
 * starts.
 *
 * @generated from enum video_widevine.License.Policy.TimerDelayBase
 */
export enum License_Policy_TimerDelayBase {
    /**
     * Not specified
     *
     * @generated from enum value: TIMER_DELAY_BASE_UNSPECIFIED = 0;
     */
    TIMER_DELAY_BASE_UNSPECIFIED = 0,

    /**
     * The timer delay is based on |license_start_time|.
     *
     * @generated from enum value: LICENSE_START = 1;
     */
    LICENSE_START = 1,

    /**
     * The timer delay is based on the time the license is received by the
     * client, whether the license is newly issued by the server or loaded
     * from the disk (for persistent licenses).
     * IMPORTANT: The playback window also begins immediately at license load
     * time.
     *
     * @generated from enum value: LICENSE_LOAD = 2;
     */
    LICENSE_LOAD = 2,

    /**
     * The timer delay is based on the time of first decryption.
     * NOTE: For persistent licenses, the first decryption time should be
     * persisted so that the "first decrypt" should only happen once even when
     * the license is loaded repeatedly.
     *
     * @generated from enum value: FIRST_DECRYPT = 3;
     */
    FIRST_DECRYPT = 3
}

/**
 * Describes the enum video_widevine.License.Policy.TimerDelayBase.
 */
export const License_Policy_TimerDelayBaseSchema: GenEnum<License_Policy_TimerDelayBase> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 0, 1)

/**
 * @generated from message video_widevine.License.KeyContainer
 */
export type License_KeyContainer =
    Message<'video_widevine.License.KeyContainer'> & {
        /**
         * @generated from field: optional bytes id = 1;
         */
        id: Uint8Array

        /**
         * @generated from field: optional bytes iv = 2;
         */
        iv: Uint8Array

        /**
         * @generated from field: optional bytes key = 3;
         */
        key: Uint8Array

        /**
         * @generated from field: optional video_widevine.License.KeyContainer.KeyType type = 4;
         */
        type: License_KeyContainer_KeyType

        /**
         * @generated from field: optional video_widevine.License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];
         */
        level: License_KeyContainer_SecurityLevel

        /**
         * @generated from field: optional video_widevine.License.KeyContainer.OutputProtection required_protection = 6;
         */
        requiredProtection?: License_KeyContainer_OutputProtection

        /**
         * NOTE: Use of requested_protection is not recommended as it is only
         * supported on a small number of platforms.
         *
         * @generated from field: optional video_widevine.License.KeyContainer.OutputProtection requested_protection = 7;
         */
        requestedProtection?: License_KeyContainer_OutputProtection

        /**
         * @generated from field: optional video_widevine.License.KeyContainer.KeyControl key_control = 8;
         */
        keyControl?: License_KeyContainer_KeyControl

        /**
         * @generated from field: optional video_widevine.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
         */
        operatorSessionKeyPermissions?: License_KeyContainer_OperatorSessionKeyPermissions

        /**
         * Optional video resolution constraints. If the video resolution of the
         * content being decrypted/decoded falls within one of the specified ranges,
         * the optional required_protections may be applied. Otherwise an error will
         * be reported.
         * NOTE: Use of this feature is not recommended, as it is only supported on
         * a small number of platforms.
         *
         * @generated from field: repeated video_widevine.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
         */
        videoResolutionConstraints: License_KeyContainer_VideoResolutionConstraint[]

        /**
         * Optional flag to indicate the key must only be used if the client
         * supports anti rollback of the user table.  Content provider can query the
         * client capabilities to determine if the client support this feature.
         *
         * @generated from field: optional bool anti_rollback_usage_table = 11 [default = false];
         */
        antiRollbackUsageTable: boolean

        /**
         * Optional not limited to commonly known track types such as SD, HD.
         * It can be some provider defined label to identify the track.
         *
         * @generated from field: optional string track_label = 12;
         */
        trackLabel: string

        /**
         * Optional. It is used to identify if current key is generated for a
         * single content or a group of contents. Currently it is only used in CAS
         * request.
         *
         * @generated from field: optional video_widevine.License.KeyContainer.KeyCategorySpec key_category_spec = 13;
         */
        keyCategorySpec?: License_KeyContainer_KeyCategorySpec

        /**
         * Optional. Used by Moho API for Content key encryption. If unspecified,
         * the Moho code uses the encryption scheme of type AES128_CTR.
         *
         * @generated from field: optional video_widevine.License.KeyContainer.EncryptionScheme encryption_scheme = 14 [default = ENCRYPTION_SCHEME_UNSPECIFIED];
         */
        encryptionScheme: License_KeyContainer_EncryptionScheme
    }

/**
 * Describes the message video_widevine.License.KeyContainer.
 * Use `create(License_KeyContainerSchema)` to create a new message.
 */
export const License_KeyContainerSchema: GenMessage<License_KeyContainer> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5, 1)

/**
 * @generated from message video_widevine.License.KeyContainer.KeyControl
 */
export type License_KeyContainer_KeyControl =
    Message<'video_widevine.License.KeyContainer.KeyControl'> & {
        /**
         * If present, the key control must be communicated to the secure
         * environment prior to any usage. This message is automatically generated
         * by the Widevine License Server SDK.
         *
         * @generated from field: optional bytes key_control_block = 1;
         */
        keyControlBlock: Uint8Array

        /**
         * @generated from field: optional bytes iv = 2;
         */
        iv: Uint8Array
    }

/**
 * Describes the message video_widevine.License.KeyContainer.KeyControl.
 * Use `create(License_KeyContainer_KeyControlSchema)` to create a new message.
 */
export const License_KeyContainer_KeyControlSchema: GenMessage<License_KeyContainer_KeyControl> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5, 1, 0)

/**
 * @generated from message video_widevine.License.KeyContainer.OutputProtection
 */
export type License_KeyContainer_OutputProtection =
    Message<'video_widevine.License.KeyContainer.OutputProtection'> & {
        /**
         * @generated from field: optional video_widevine.License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];
         */
        hdcp: License_KeyContainer_OutputProtection_HDCP

        /**
         * @generated from field: optional video_widevine.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];
         */
        cgmsFlags: License_KeyContainer_OutputProtection_CGMS

        /**
         * @generated from field: optional video_widevine.License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];
         */
        hdcpSrmRule: License_KeyContainer_OutputProtection_HdcpSrmRule

        /**
         * Optional requirement to indicate analog output is not allowed.
         *
         * @generated from field: optional bool disable_analog_output = 4 [default = false];
         */
        disableAnalogOutput: boolean

        /**
         * Optional requirement to indicate digital output is not allowed.
         *
         * @generated from field: optional bool disable_digital_output = 5 [default = false];
         */
        disableDigitalOutput: boolean

        /**
         * Optional. If set, it indicates digital video recording (DVR) is
         * allowed.
         *
         * @generated from field: optional bool allow_record = 6 [default = false];
         */
        allowRecord: boolean
    }

/**
 * Describes the message video_widevine.License.KeyContainer.OutputProtection.
 * Use `create(License_KeyContainer_OutputProtectionSchema)` to create a new message.
 */
export const License_KeyContainer_OutputProtectionSchema: GenMessage<License_KeyContainer_OutputProtection> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5, 1, 1)

/**
 * Indicates whether HDCP is required on digital outputs, and which
 * version should be used.
 *
 * @generated from enum video_widevine.License.KeyContainer.OutputProtection.HDCP
 */
export enum License_KeyContainer_OutputProtection_HDCP {
    /**
     * @generated from enum value: HDCP_NONE = 0;
     */
    HDCP_NONE = 0,

    /**
     * @generated from enum value: HDCP_V1 = 1;
     */
    HDCP_V1 = 1,

    /**
     * @generated from enum value: HDCP_V2 = 2;
     */
    HDCP_V2 = 2,

    /**
     * @generated from enum value: HDCP_V2_1 = 3;
     */
    HDCP_V2_1 = 3,

    /**
     * @generated from enum value: HDCP_V2_2 = 4;
     */
    HDCP_V2_2 = 4,

    /**
     * @generated from enum value: HDCP_V2_3 = 5;
     */
    HDCP_V2_3 = 5,

    /**
     * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
     */
    HDCP_NO_DIGITAL_OUTPUT = 255
}

/**
 * Describes the enum video_widevine.License.KeyContainer.OutputProtection.HDCP.
 */
export const License_KeyContainer_OutputProtection_HDCPSchema: GenEnum<License_KeyContainer_OutputProtection_HDCP> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 1, 1, 0)

/**
 * Indicate the CGMS setting to be inserted on analog output.
 *
 * @generated from enum video_widevine.License.KeyContainer.OutputProtection.CGMS
 */
export enum License_KeyContainer_OutputProtection_CGMS {
    /**
     * @generated from enum value: CGMS_NONE = 42;
     */
    CGMS_NONE = 42,

    /**
     * @generated from enum value: COPY_FREE = 0;
     */
    COPY_FREE = 0,

    /**
     * @generated from enum value: COPY_ONCE = 2;
     */
    COPY_ONCE = 2,

    /**
     * @generated from enum value: COPY_NEVER = 3;
     */
    COPY_NEVER = 3
}

/**
 * Describes the enum video_widevine.License.KeyContainer.OutputProtection.CGMS.
 */
export const License_KeyContainer_OutputProtection_CGMSSchema: GenEnum<License_KeyContainer_OutputProtection_CGMS> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 1, 1, 1)

/**
 * @generated from enum video_widevine.License.KeyContainer.OutputProtection.HdcpSrmRule
 */
export enum License_KeyContainer_OutputProtection_HdcpSrmRule {
    /**
     * @generated from enum value: HDCP_SRM_RULE_NONE = 0;
     */
    HDCP_SRM_RULE_NONE = 0,

    /**
     * In 'required_protection', this means most current SRM is required.
     * Update the SRM on the device. If update cannot happen,
     * do not allow the key.
     * In 'requested_protection', this means most current SRM is requested.
     * Update the SRM on the device. If update cannot happen,
     * allow use of the key anyway.
     *
     * @generated from enum value: CURRENT_SRM = 1;
     */
    CURRENT_SRM = 1
}

/**
 * Describes the enum video_widevine.License.KeyContainer.OutputProtection.HdcpSrmRule.
 */
export const License_KeyContainer_OutputProtection_HdcpSrmRuleSchema: GenEnum<License_KeyContainer_OutputProtection_HdcpSrmRule> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 1, 1, 2)

/**
 * @generated from message video_widevine.License.KeyContainer.VideoResolutionConstraint
 */
export type License_KeyContainer_VideoResolutionConstraint =
    Message<'video_widevine.License.KeyContainer.VideoResolutionConstraint'> & {
        /**
         * Minimum and maximum video resolutions in the range (height x width).
         *
         * @generated from field: optional uint32 min_resolution_pixels = 1;
         */
        minResolutionPixels: number

        /**
         * @generated from field: optional uint32 max_resolution_pixels = 2;
         */
        maxResolutionPixels: number

        /**
         * Optional output protection requirements for this range. If not
         * specified, the OutputProtection in the KeyContainer applies.
         *
         * @generated from field: optional video_widevine.License.KeyContainer.OutputProtection required_protection = 3;
         */
        requiredProtection?: License_KeyContainer_OutputProtection
    }

/**
 * Describes the message video_widevine.License.KeyContainer.VideoResolutionConstraint.
 * Use `create(License_KeyContainer_VideoResolutionConstraintSchema)` to create a new message.
 */
export const License_KeyContainer_VideoResolutionConstraintSchema: GenMessage<License_KeyContainer_VideoResolutionConstraint> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5, 1, 2)

/**
 * @generated from message video_widevine.License.KeyContainer.OperatorSessionKeyPermissions
 */
export type License_KeyContainer_OperatorSessionKeyPermissions =
    Message<'video_widevine.License.KeyContainer.OperatorSessionKeyPermissions'> & {
        /**
         * Permissions/key usage flags for operator service keys
         * (type = OPERATOR_SESSION).
         *
         * @generated from field: optional bool allow_encrypt = 1 [default = false];
         */
        allowEncrypt: boolean

        /**
         * @generated from field: optional bool allow_decrypt = 2 [default = false];
         */
        allowDecrypt: boolean

        /**
         * @generated from field: optional bool allow_sign = 3 [default = false];
         */
        allowSign: boolean

        /**
         * @generated from field: optional bool allow_signature_verify = 4 [default = false];
         */
        allowSignatureVerify: boolean
    }

/**
 * Describes the message video_widevine.License.KeyContainer.OperatorSessionKeyPermissions.
 * Use `create(License_KeyContainer_OperatorSessionKeyPermissionsSchema)` to create a new message.
 */
export const License_KeyContainer_OperatorSessionKeyPermissionsSchema: GenMessage<License_KeyContainer_OperatorSessionKeyPermissions> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5, 1, 3)

/**
 * KeyCategorySpec message is used to identify if current key is generated
 * for a single content or a group of contents. Currently it is only used in
 * CAS request.
 *
 * @generated from message video_widevine.License.KeyContainer.KeyCategorySpec
 */
export type License_KeyContainer_KeyCategorySpec =
    Message<'video_widevine.License.KeyContainer.KeyCategorySpec'> & {
        /**
         * Indicate if the current key is created for single content or for group
         * use.
         *
         * @generated from field: optional video_widevine.License.KeyContainer.KeyCategorySpec.KeyCategory key_category = 1;
         */
        keyCategory: License_KeyContainer_KeyCategorySpec_KeyCategory

        /**
         * Id for key category. If it is a key for single content, this id
         * represents the content_id. Otherwise, it represents a group_id.
         *
         * @generated from oneof video_widevine.License.KeyContainer.KeyCategorySpec.content_or_group_id
         */
        contentOrGroupId:
            | {
                  /**
                   * @generated from field: bytes content_id = 2;
                   */
                  value: Uint8Array
                  case: 'contentId'
              }
            | {
                  /**
                   * @generated from field: bytes group_id = 3;
                   */
                  value: Uint8Array
                  case: 'groupId'
              }
            | { case: undefined; value?: undefined }
    }

/**
 * Describes the message video_widevine.License.KeyContainer.KeyCategorySpec.
 * Use `create(License_KeyContainer_KeyCategorySpecSchema)` to create a new message.
 */
export const License_KeyContainer_KeyCategorySpecSchema: GenMessage<License_KeyContainer_KeyCategorySpec> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 5, 1, 4)

/**
 * Represents what kind of content a key is used for.
 *
 * @generated from enum video_widevine.License.KeyContainer.KeyCategorySpec.KeyCategory
 */
export enum License_KeyContainer_KeyCategorySpec_KeyCategory {
    /**
     * By default, key is created for single content.
     *
     * @generated from enum value: SINGLE_CONTENT_KEY_DEFAULT = 0;
     */
    SINGLE_CONTENT_KEY_DEFAULT = 0,

    /**
     * Key is created for a group of contents.
     *
     * @generated from enum value: GROUP_KEY = 1;
     */
    GROUP_KEY = 1
}

/**
 * Describes the enum video_widevine.License.KeyContainer.KeyCategorySpec.KeyCategory.
 */
export const License_KeyContainer_KeyCategorySpec_KeyCategorySchema: GenEnum<License_KeyContainer_KeyCategorySpec_KeyCategory> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 1, 4, 0)

/**
 * @generated from enum video_widevine.License.KeyContainer.KeyType
 */
export enum License_KeyContainer_KeyType {
    /**
     * No more than one signing key may appear.
     *
     * @generated from enum value: SIGNING = 1;
     */
    SIGNING = 1,

    /**
     * Content key.
     *
     * @generated from enum value: CONTENT = 2;
     */
    CONTENT = 2,

    /**
     * Key control block for license renewals. No key.
     *
     * @generated from enum value: KEY_CONTROL = 3;
     */
    KEY_CONTROL = 3,

    /**
     * wrapped keys for auxiliary crypto operations.
     *
     * @generated from enum value: OPERATOR_SESSION = 4;
     */
    OPERATOR_SESSION = 4,

    /**
     * Entitlement keys.
     *
     * @generated from enum value: ENTITLEMENT = 5;
     */
    ENTITLEMENT = 5,

    /**
     * Partner-specific content key.
     *
     * @generated from enum value: OEM_CONTENT = 6;
     */
    OEM_CONTENT = 6,

    /**
     * Public signing key provided by content providers. Currently used by CAS
     * for verifying the received ECM/EMM signature. Only EC key is supported
     * for now.
     *
     * @generated from enum value: PROVIDER_ECM_VERIFIER_PUBLIC_KEY = 7;
     */
    PROVIDER_ECM_VERIFIER_PUBLIC_KEY = 7,

    /**
     * Partner-specific entitlement key.
     *
     * @generated from enum value: OEM_ENTITLEMENT = 8;
     */
    OEM_ENTITLEMENT = 8
}

/**
 * Describes the enum video_widevine.License.KeyContainer.KeyType.
 */
export const License_KeyContainer_KeyTypeSchema: GenEnum<License_KeyContainer_KeyType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 1, 0)

/**
 * The SecurityLevel enumeration allows the server to communicate the level
 * of robustness required by the client, in order to use the key.
 *
 * @generated from enum video_widevine.License.KeyContainer.SecurityLevel
 */
export enum License_KeyContainer_SecurityLevel {
    /**
     * Software-based whitebox crypto is required.
     *
     * @generated from enum value: SW_SECURE_CRYPTO = 1;
     */
    SW_SECURE_CRYPTO = 1,

    /**
     * Software crypto and an obfuscated decoder is required.
     *
     * @generated from enum value: SW_SECURE_DECODE = 2;
     */
    SW_SECURE_DECODE = 2,

    /**
     * The key material and crypto operations must be performed within a
     * hardware backed trusted execution environment.
     *
     * @generated from enum value: HW_SECURE_CRYPTO = 3;
     */
    HW_SECURE_CRYPTO = 3,

    /**
     * The crypto and decoding of content must be performed within a hardware
     * backed trusted execution environment.
     *
     * @generated from enum value: HW_SECURE_DECODE = 4;
     */
    HW_SECURE_DECODE = 4,

    /**
     * The crypto, decoding and all handling of the media (compressed and
     * uncompressed) must be handled within a hardware backed trusted
     * execution environment.
     *
     * @generated from enum value: HW_SECURE_ALL = 5;
     */
    HW_SECURE_ALL = 5
}

/**
 * Describes the enum video_widevine.License.KeyContainer.SecurityLevel.
 */
export const License_KeyContainer_SecurityLevelSchema: GenEnum<License_KeyContainer_SecurityLevel> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 1, 1)

/**
 * The EncryptionScheme to be used for the content keys.  This is applicable
 * only to Moho API.
 *
 * @generated from enum video_widevine.License.KeyContainer.EncryptionScheme
 */
export enum License_KeyContainer_EncryptionScheme {
    /**
     * @generated from enum value: ENCRYPTION_SCHEME_UNSPECIFIED = 0;
     */
    ENCRYPTION_SCHEME_UNSPECIFIED = 0,

    /**
     * @generated from enum value: AES128_CTR = 1;
     */
    AES128_CTR = 1,

    /**
     * @generated from enum value: AES128_CBC = 2;
     */
    AES128_CBC = 2
}

/**
 * Describes the enum video_widevine.License.KeyContainer.EncryptionScheme.
 */
export const License_KeyContainer_EncryptionSchemeSchema: GenEnum<License_KeyContainer_EncryptionScheme> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 5, 1, 2)

/**
 * @generated from message video_widevine.LicenseRequest
 */
export type LicenseRequest = Message<'video_widevine.LicenseRequest'> & {
    /**
     * The client_id provides information authenticating the calling device.  It
     * contains the Widevine keybox token that was installed on the device at the
     * factory.  This field or encrypted_client_id below is required for a valid
     * license request, but both should never be present in the same request.
     *
     * @generated from field: optional video_widevine.ClientIdentification client_id = 1;
     */
    clientId?: ClientIdentification

    /**
     * @generated from field: optional video_widevine.LicenseRequest.ContentIdentification content_id = 2;
     */
    contentId?: LicenseRequest_ContentIdentification

    /**
     * @generated from field: optional video_widevine.LicenseRequest.RequestType type = 3;
     */
    type: LicenseRequest_RequestType

    /**
     * Time of the request in seconds (UTC) as set by the client.
     *
     * @generated from field: optional int64 request_time = 4;
     */
    requestTime: bigint

    /**
     * Old-style decimal-encoded string key control nonce.
     *
     * @generated from field: optional bytes key_control_nonce_deprecated = 5;
     */
    keyControlNonceDeprecated: Uint8Array

    /**
     * @generated from field: optional video_widevine.ProtocolVersion protocol_version = 6 [default = VERSION_2_0];
     */
    protocolVersion: ProtocolVersion

    /**
     * New-style uint32 key control nonce, please use instead of
     * key_control_nonce_deprecated.
     *
     * @generated from field: optional uint32 key_control_nonce = 7;
     */
    keyControlNonce: number

    /**
     * Encrypted ClientIdentification message, used for privacy purposes.
     *
     * @generated from field: optional video_widevine.EncryptedClientIdentification encrypted_client_id = 8;
     */
    encryptedClientId?: EncryptedClientIdentification

    /**
     * The version of the client implementation. This field is optional and
     * informational only.
     *
     * @generated from field: optional string client_version = 9;
     */
    clientVersion: string
}

/**
 * Describes the message video_widevine.LicenseRequest.
 * Use `create(LicenseRequestSchema)` to create a new message.
 */
export const LicenseRequestSchema: GenMessage<LicenseRequest> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 6)

/**
 * @generated from message video_widevine.LicenseRequest.ContentIdentification
 */
export type LicenseRequest_ContentIdentification =
    Message<'video_widevine.LicenseRequest.ContentIdentification'> & {
        /**
         * @generated from oneof video_widevine.LicenseRequest.ContentIdentification.content_id_variant
         */
        contentIdVariant:
            | {
                  /**
                   * Exactly one of these must be present.
                   *
                   * @generated from field: video_widevine.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;
                   */
                  value: LicenseRequest_ContentIdentification_WidevinePsshData
                  case: 'widevinePsshData'
              }
            | {
                  /**
                   * @generated from field: video_widevine.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;
                   */
                  value: LicenseRequest_ContentIdentification_WebmKeyId
                  case: 'webmKeyId'
              }
            | {
                  /**
                   * @generated from field: video_widevine.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;
                   */
                  value: LicenseRequest_ContentIdentification_ExistingLicense
                  case: 'existingLicense'
              }
            | {
                  /**
                   * @generated from field: video_widevine.LicenseRequest.ContentIdentification.InitData init_data = 4;
                   */
                  value: LicenseRequest_ContentIdentification_InitData
                  case: 'initData'
              }
            | { case: undefined; value?: undefined }
    }

/**
 * Describes the message video_widevine.LicenseRequest.ContentIdentification.
 * Use `create(LicenseRequest_ContentIdentificationSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentificationSchema: GenMessage<LicenseRequest_ContentIdentification> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 6, 0)

/**
 * @generated from message video_widevine.LicenseRequest.ContentIdentification.WidevinePsshData
 */
export type LicenseRequest_ContentIdentification_WidevinePsshData =
    Message<'video_widevine.LicenseRequest.ContentIdentification.WidevinePsshData'> & {
        /**
         * @generated from field: repeated bytes pssh_data = 1;
         */
        psshData: Uint8Array[]

        /**
         * @generated from field: optional video_widevine.LicenseType license_type = 2;
         */
        licenseType: LicenseType

        /**
         * Opaque, client-specified.
         *
         * @generated from field: optional bytes request_id = 3;
         */
        requestId: Uint8Array
    }

/**
 * Describes the message video_widevine.LicenseRequest.ContentIdentification.WidevinePsshData.
 * Use `create(LicenseRequest_ContentIdentification_WidevinePsshDataSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_WidevinePsshDataSchema: GenMessage<LicenseRequest_ContentIdentification_WidevinePsshData> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 6, 0, 0)

/**
 * @generated from message video_widevine.LicenseRequest.ContentIdentification.WebmKeyId
 */
export type LicenseRequest_ContentIdentification_WebmKeyId =
    Message<'video_widevine.LicenseRequest.ContentIdentification.WebmKeyId'> & {
        /**
         * @generated from field: optional bytes header = 1;
         */
        header: Uint8Array

        /**
         * @generated from field: optional video_widevine.LicenseType license_type = 2;
         */
        licenseType: LicenseType

        /**
         * Opaque, client-specified.
         *
         * @generated from field: optional bytes request_id = 3;
         */
        requestId: Uint8Array
    }

/**
 * Describes the message video_widevine.LicenseRequest.ContentIdentification.WebmKeyId.
 * Use `create(LicenseRequest_ContentIdentification_WebmKeyIdSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_WebmKeyIdSchema: GenMessage<LicenseRequest_ContentIdentification_WebmKeyId> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 6, 0, 1)

/**
 * @generated from message video_widevine.LicenseRequest.ContentIdentification.ExistingLicense
 */
export type LicenseRequest_ContentIdentification_ExistingLicense =
    Message<'video_widevine.LicenseRequest.ContentIdentification.ExistingLicense'> & {
        /**
         * @generated from field: optional video_widevine.LicenseIdentification license_id = 1;
         */
        licenseId?: LicenseIdentification

        /**
         * @generated from field: optional int64 seconds_since_started = 2;
         */
        secondsSinceStarted: bigint

        /**
         * @generated from field: optional int64 seconds_since_last_played = 3;
         */
        secondsSinceLastPlayed: bigint

        /**
         * @generated from field: optional bytes session_usage_table_entry = 4;
         */
        sessionUsageTableEntry: Uint8Array
    }

/**
 * Describes the message video_widevine.LicenseRequest.ContentIdentification.ExistingLicense.
 * Use `create(LicenseRequest_ContentIdentification_ExistingLicenseSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_ExistingLicenseSchema: GenMessage<LicenseRequest_ContentIdentification_ExistingLicense> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 6, 0, 2)

/**
 * @generated from message video_widevine.LicenseRequest.ContentIdentification.InitData
 */
export type LicenseRequest_ContentIdentification_InitData =
    Message<'video_widevine.LicenseRequest.ContentIdentification.InitData'> & {
        /**
         * @generated from field: optional video_widevine.LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];
         */
        initDataType: LicenseRequest_ContentIdentification_InitData_InitDataType

        /**
         * @generated from field: optional bytes init_data = 2;
         */
        initData: Uint8Array

        /**
         * @generated from field: optional video_widevine.LicenseType license_type = 3;
         */
        licenseType: LicenseType

        /**
         * @generated from field: optional bytes request_id = 4;
         */
        requestId: Uint8Array
    }

/**
 * Describes the message video_widevine.LicenseRequest.ContentIdentification.InitData.
 * Use `create(LicenseRequest_ContentIdentification_InitDataSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_InitDataSchema: GenMessage<LicenseRequest_ContentIdentification_InitData> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 6, 0, 3)

/**
 * @generated from enum video_widevine.LicenseRequest.ContentIdentification.InitData.InitDataType
 */
export enum LicenseRequest_ContentIdentification_InitData_InitDataType {
    /**
     * @generated from enum value: CENC = 1;
     */
    CENC = 1,

    /**
     * @generated from enum value: WEBM = 2;
     */
    WEBM = 2
}

/**
 * Describes the enum video_widevine.LicenseRequest.ContentIdentification.InitData.InitDataType.
 */
export const LicenseRequest_ContentIdentification_InitData_InitDataTypeSchema: GenEnum<LicenseRequest_ContentIdentification_InitData_InitDataType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 6, 0, 3, 0)

/**
 * @generated from enum video_widevine.LicenseRequest.RequestType
 */
export enum LicenseRequest_RequestType {
    /**
     * @generated from enum value: NEW = 1;
     */
    NEW = 1,

    /**
     * @generated from enum value: RENEWAL = 2;
     */
    RENEWAL = 2,

    /**
     * @generated from enum value: RELEASE = 3;
     */
    RELEASE = 3
}

/**
 * Describes the enum video_widevine.LicenseRequest.RequestType.
 */
export const LicenseRequest_RequestTypeSchema: GenEnum<LicenseRequest_RequestType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 6, 0)

/**
 * @generated from message video_widevine.LicenseError
 */
export type LicenseError = Message<'video_widevine.LicenseError'> & {
    /**
     * @generated from field: optional video_widevine.LicenseError.Error error_code = 1;
     */
    errorCode: LicenseError_Error
}

/**
 * Describes the message video_widevine.LicenseError.
 * Use `create(LicenseErrorSchema)` to create a new message.
 */
export const LicenseErrorSchema: GenMessage<LicenseError> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 7)

/**
 * @generated from enum video_widevine.LicenseError.Error
 */
export enum LicenseError_Error {
    /**
     * The device credentials are invalid. The device must re-provision.
     *
     * @generated from enum value: INVALID_DRM_DEVICE_CERTIFICATE = 1;
     */
    INVALID_DRM_DEVICE_CERTIFICATE = 1,

    /**
     * The device credentials have been revoked. Re-provisioning is not
     * possible.
     *
     * @generated from enum value: REVOKED_DRM_DEVICE_CERTIFICATE = 2;
     */
    REVOKED_DRM_DEVICE_CERTIFICATE = 2,

    /**
     * The service is currently unavailable due to the backend being down
     * or similar circumstances.
     *
     * @generated from enum value: SERVICE_UNAVAILABLE = 3;
     */
    SERVICE_UNAVAILABLE = 3,

    /**
     * The device credentials are expired. The device must re-provision.
     *
     * @generated from enum value: EXPIRED_DRM_DEVICE_CERTIFICATE = 4;
     */
    EXPIRED_DRM_DEVICE_CERTIFICATE = 4
}

/**
 * Describes the enum video_widevine.LicenseError.Error.
 */
export const LicenseError_ErrorSchema: GenEnum<LicenseError_Error> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 7, 0)

/**
 * @generated from message video_widevine.MetricData
 */
export type MetricData = Message<'video_widevine.MetricData'> & {
    /**
     * 'stage' that is currently processing the SignedMessage.  Required.
     *
     * @generated from field: optional string stage_name = 1;
     */
    stageName: string

    /**
     * metric and associated value.
     *
     * @generated from field: repeated video_widevine.MetricData.TypeValue metric_data = 2;
     */
    metricData: MetricData_TypeValue[]
}

/**
 * Describes the message video_widevine.MetricData.
 * Use `create(MetricDataSchema)` to create a new message.
 */
export const MetricDataSchema: GenMessage<MetricData> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 8)

/**
 * @generated from message video_widevine.MetricData.TypeValue
 */
export type MetricData_TypeValue =
    Message<'video_widevine.MetricData.TypeValue'> & {
        /**
         * @generated from field: optional video_widevine.MetricData.MetricType type = 1;
         */
        type: MetricData_MetricType

        /**
         * The value associated with 'type'.  For example if type == LATENCY, the
         * value would be the time in microseconds spent in this 'stage'.
         *
         * @generated from field: optional int64 value = 2 [default = 0];
         */
        value: bigint
    }

/**
 * Describes the message video_widevine.MetricData.TypeValue.
 * Use `create(MetricData_TypeValueSchema)` to create a new message.
 */
export const MetricData_TypeValueSchema: GenMessage<MetricData_TypeValue> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 8, 0)

/**
 * @generated from enum video_widevine.MetricData.MetricType
 */
export enum MetricData_MetricType {
    /**
     * The time spent in the 'stage', specified in microseconds.
     *
     * @generated from enum value: LATENCY = 1;
     */
    LATENCY = 1,

    /**
     * The UNIX epoch timestamp at which the 'stage' was first accessed in
     * microseconds.
     *
     * @generated from enum value: TIMESTAMP = 2;
     */
    TIMESTAMP = 2
}

/**
 * Describes the enum video_widevine.MetricData.MetricType.
 */
export const MetricData_MetricTypeSchema: GenEnum<MetricData_MetricType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 8, 0)

/**
 * @generated from message video_widevine.VersionInfo
 */
export type VersionInfo = Message<'video_widevine.VersionInfo'> & {
    /**
     * License SDK version reported by the Widevine License SDK. This field
     * is populated automatically by the SDK.
     *
     * @generated from field: optional string license_sdk_version = 1;
     */
    licenseSdkVersion: string

    /**
     * Version of the service hosting the license SDK. This field is optional.
     * It may be provided by the hosting service.
     *
     * @generated from field: optional string license_service_version = 2;
     */
    licenseServiceVersion: string
}

/**
 * Describes the message video_widevine.VersionInfo.
 * Use `create(VersionInfoSchema)` to create a new message.
 */
export const VersionInfoSchema: GenMessage<VersionInfo> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 9)

/**
 * @generated from message video_widevine.SignedMessage
 */
export type SignedMessage = Message<'video_widevine.SignedMessage'> & {
    /**
     * @generated from field: optional video_widevine.SignedMessage.MessageType type = 1;
     */
    type: SignedMessage_MessageType

    /**
     * @generated from field: optional bytes msg = 2;
     */
    msg: Uint8Array

    /**
     * Required field that contains the signature of the bytes of msg.
     * For license requests, the signing algorithm is determined by the
     * certificate contained in the request.
     * For license responses, the signing algorithm is HMAC with signing key based
     * on |session_key|.
     *
     * @generated from field: optional bytes signature = 3;
     */
    signature: Uint8Array

    /**
     * If populated, the contents of this field will be signaled by the
     * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
     * key is the bytes of an encrypted AES key. If the |session_key_type| is
     * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
     * serialized ECC public key.
     *
     * @generated from field: optional bytes session_key = 4;
     */
    sessionKey: Uint8Array

    /**
     * Remote attestation data which will be present in the initial license
     * request for ChromeOS client devices operating in verified mode. Remote
     * attestation challenge data is |msg| field above. Optional.
     *
     * @generated from field: optional video_widevine.RemoteAttestation remote_attestation = 5;
     */
    remoteAttestation?: RemoteAttestation

    /**
     * @generated from field: repeated video_widevine.MetricData metric_data = 6;
     */
    metricData: MetricData[]

    /**
     * Version information from the SDK and license service. This information is
     * provided in the license response.
     *
     * @generated from field: optional video_widevine.VersionInfo service_version_info = 7;
     */
    serviceVersionInfo?: VersionInfo

    /**
     * Optional field that contains the algorithm type used to generate the
     * session_key and signature in a LICENSE message.
     *
     * @generated from field: optional video_widevine.SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];
     */
    sessionKeyType: SignedMessage_SessionKeyType

    /**
     * The core message is the simple serialization of fields used by OEMCrypto.
     * This field was introduced in OEMCrypto API v16.
     *
     * @generated from field: optional bytes oemcrypto_core_message = 9;
     */
    oemcryptoCoreMessage: Uint8Array

    /**
     * Optional field that indicates the hash algorithm used in signature scheme.
     *
     * @generated from field: optional video_widevine.HashAlgorithmProto hash_algorithm = 10;
     */
    hashAlgorithm: HashAlgorithmProto

    /**
     * If true it indicates that a LICENSE message session key was based on an
     * alternate key provided by the client credentials.
     *
     * @generated from field: optional bool using_secondary_key = 11;
     */
    usingSecondaryKey: boolean
}

/**
 * Describes the message video_widevine.SignedMessage.
 * Use `create(SignedMessageSchema)` to create a new message.
 */
export const SignedMessageSchema: GenMessage<SignedMessage> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 10)

/**
 * @generated from enum video_widevine.SignedMessage.MessageType
 */
export enum SignedMessage_MessageType {
    /**
     * @generated from enum value: LICENSE_REQUEST = 1;
     */
    LICENSE_REQUEST = 1,

    /**
     * @generated from enum value: LICENSE = 2;
     */
    LICENSE = 2,

    /**
     * @generated from enum value: ERROR_RESPONSE = 3;
     */
    ERROR_RESPONSE = 3,

    /**
     * @generated from enum value: SERVICE_CERTIFICATE_REQUEST = 4;
     */
    SERVICE_CERTIFICATE_REQUEST = 4,

    /**
     * @generated from enum value: SERVICE_CERTIFICATE = 5;
     */
    SERVICE_CERTIFICATE = 5,

    /**
     * @generated from enum value: SUB_LICENSE = 6;
     */
    SUB_LICENSE = 6,

    /**
     * @generated from enum value: CAS_LICENSE_REQUEST = 7;
     */
    CAS_LICENSE_REQUEST = 7,

    /**
     * @generated from enum value: CAS_LICENSE = 8;
     */
    CAS_LICENSE = 8,

    /**
     * @generated from enum value: EXTERNAL_LICENSE_REQUEST = 9;
     */
    EXTERNAL_LICENSE_REQUEST = 9,

    /**
     * @generated from enum value: EXTERNAL_LICENSE = 10;
     */
    EXTERNAL_LICENSE = 10
}

/**
 * Describes the enum video_widevine.SignedMessage.MessageType.
 */
export const SignedMessage_MessageTypeSchema: GenEnum<SignedMessage_MessageType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 10, 0)

/**
 * @generated from enum video_widevine.SignedMessage.SessionKeyType
 */
export enum SignedMessage_SessionKeyType {
    /**
     * @generated from enum value: UNDEFINED = 0;
     */
    UNDEFINED = 0,

    /**
     * @generated from enum value: WRAPPED_AES_KEY = 1;
     */
    WRAPPED_AES_KEY = 1,

    /**
     * @generated from enum value: EPHEMERAL_ECC_PUBLIC_KEY = 2;
     */
    EPHEMERAL_ECC_PUBLIC_KEY = 2
}

/**
 * Describes the enum video_widevine.SignedMessage.SessionKeyType.
 */
export const SignedMessage_SessionKeyTypeSchema: GenEnum<SignedMessage_SessionKeyType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 10, 1)

/**
 * A KeyToCertify contains a client generated public key to be incorporated into
 * a signed certificate.
 *
 * @generated from message video_widevine.PublicKeyToCertify
 */
export type PublicKeyToCertify =
    Message<'video_widevine.PublicKeyToCertify'> & {
        /**
         * |public_key| contains the bytes of a PKCS#1 ASN.1 DER-encoded public key.
         *
         * @generated from field: optional bytes public_key = 1;
         */
        publicKey: Uint8Array

        /**
         * KeyType contains a highlevel hint to use in parsing the serialized key
         * contained in |public_key|. If the key is an EC key, curve parameters can be
         * extracted from the deserialized key.
         * Keys are expected to match the certificate key type in the device
         * record.
         *
         * @generated from field: optional video_widevine.PublicKeyToCertify.KeyType key_type = 2;
         */
        keyType: PublicKeyToCertify_KeyType

        /**
         * The signature of |public_key|.
         * Keys that are signed using ECDSA or RSA should hash the message using
         * SHA-256.
         *
         * @generated from field: optional bytes signature = 3;
         */
        signature: Uint8Array
    }

/**
 * Describes the message video_widevine.PublicKeyToCertify.
 * Use `create(PublicKeyToCertifySchema)` to create a new message.
 */
export const PublicKeyToCertifySchema: GenMessage<PublicKeyToCertify> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 11)

/**
 * A KeyType indicates a high level key type.
 *
 * @generated from enum video_widevine.PublicKeyToCertify.KeyType
 */
export enum PublicKeyToCertify_KeyType {
    /**
     * @generated from enum value: KEY_TYPE_UNSPECIFIED = 0;
     */
    KEY_TYPE_UNSPECIFIED = 0,

    /**
     * @generated from enum value: RSA = 1;
     */
    RSA = 1,

    /**
     * @generated from enum value: ECC = 2;
     */
    ECC = 2
}

/**
 * Describes the enum video_widevine.PublicKeyToCertify.KeyType.
 */
export const PublicKeyToCertify_KeyTypeSchema: GenEnum<PublicKeyToCertify_KeyType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 11, 0)

/**
 * ProvisioningOptions specifies the type of certificate to specify and
 * in the case of X509 certificates, the certificate authority to use.
 *
 * @generated from message video_widevine.ProvisioningOptions
 */
export type ProvisioningOptions =
    Message<'video_widevine.ProvisioningOptions'> & {
        /**
         * @generated from field: optional video_widevine.ProvisioningOptions.CertificateType certificate_type = 1 [default = WIDEVINE_DRM];
         */
        certificateType: ProvisioningOptions_CertificateType

        /**
         * Contains the application-specific name used to identify the certificate
         * authority for signing the generated certificate. This is required if and
         * only if the certificate type is X509.
         *
         * @generated from field: optional string certificate_authority = 2;
         */
        certificateAuthority: string

        /**
         * System ID for OTA keybox provisioning. Requires device secure boot.
         *
         * @generated from field: optional uint32 system_id = 3;
         */
        systemId: number
    }

/**
 * Describes the message video_widevine.ProvisioningOptions.
 * Use `create(ProvisioningOptionsSchema)` to create a new message.
 */
export const ProvisioningOptionsSchema: GenMessage<ProvisioningOptions> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 12)

/**
 * @generated from enum video_widevine.ProvisioningOptions.CertificateType
 */
export enum ProvisioningOptions_CertificateType {
    /**
     * Default.  The original certificate type.
     *
     * @generated from enum value: WIDEVINE_DRM = 0;
     */
    WIDEVINE_DRM = 0,

    /**
     * X.509 certificate.
     *
     * @generated from enum value: X509 = 1;
     */
    X509 = 1,

    /**
     * @generated from enum value: WIDEVINE_KEYBOX = 2;
     */
    WIDEVINE_KEYBOX = 2
}

/**
 * Describes the enum video_widevine.ProvisioningOptions.CertificateType.
 */
export const ProvisioningOptions_CertificateTypeSchema: GenEnum<ProvisioningOptions_CertificateType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 12, 0)

/**
 * Provisioning request sent by client devices to provisioning service.
 *
 * @generated from message video_widevine.ProvisioningRequest
 */
export type ProvisioningRequest =
    Message<'video_widevine.ProvisioningRequest'> & {
        /**
         * @generated from oneof video_widevine.ProvisioningRequest.clear_or_encrypted_client_id
         */
        clearOrEncryptedClientId:
            | {
                  /**
                   * Device root of trust and other client identification. Required.
                   *
                   * @generated from field: video_widevine.ClientIdentification client_id = 1;
                   */
                  value: ClientIdentification
                  case: 'clientId'
              }
            | {
                  /**
                   * @generated from field: video_widevine.EncryptedClientIdentification encrypted_client_id = 5;
                   */
                  value: EncryptedClientIdentification
                  case: 'encryptedClientId'
              }
            | { case: undefined; value?: undefined }

        /**
         * Nonce value used to prevent replay attacks. Required.
         *
         * @generated from field: optional bytes nonce = 2;
         */
        nonce: Uint8Array

        /**
         * Options for type of certificate to generate.  Optional.
         *
         * @generated from field: optional video_widevine.ProvisioningOptions options = 3;
         */
        options?: ProvisioningOptions

        /**
         * @generated from oneof video_widevine.ProvisioningRequest.spoid_param
         */
        spoidParam:
            | {
                  /**
                   * Stable identifier, unique for each device + application (or origin).
                   * To be deprecated.
                   *
                   * @generated from field: bytes stable_id = 4;
                   */
                  value: Uint8Array
                  case: 'stableId'
              }
            | {
                  /**
                   * Service provider ID from the service certificate's provider_id field.
                   * Preferred parameter.
                   *
                   * @generated from field: bytes provider_id = 6;
                   */
                  value: Uint8Array
                  case: 'providerId'
              }
            | {
                  /**
                   * Client-generated stable per-origin identifier to be copied directly
                   * to the client certificate serial number.
                   *
                   * @generated from field: bytes spoid = 7;
                   */
                  value: Uint8Array
                  case: 'spoid'
              }
            | { case: undefined; value?: undefined }

        /**
         * SessionKeys encrypted using a service cert public key.
         * Required for keybox provisioning.
         *
         * @generated from field: optional video_widevine.ProvisioningRequest.EncryptedSessionKeys encrypted_session_keys = 8;
         */
        encryptedSessionKeys?: ProvisioningRequest_EncryptedSessionKeys

        /**
         * The custom request for Android Attestation OTA.
         *
         * @generated from field: optional video_widevine.ProvisioningRequest.AndroidAttestationOtaKeyboxRequest android_ota_keybox_request = 9;
         */
        androidOtaKeyboxRequest?: ProvisioningRequest_AndroidAttestationOtaKeyboxRequest

        /**
         * Specifies the public key that should be certified by the provisioning
         * server. The client holds the private key. If specified, the response no
         * longer needs to contain server generated |device_rsa_key|.
         *
         * @generated from field: optional video_widevine.PublicKeyToCertify certificate_public_key = 10;
         */
        certificatePublicKey?: PublicKeyToCertify
    }

/**
 * Describes the message video_widevine.ProvisioningRequest.
 * Use `create(ProvisioningRequestSchema)` to create a new message.
 */
export const ProvisioningRequestSchema: GenMessage<ProvisioningRequest> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 13)

/**
 * @generated from message video_widevine.ProvisioningRequest.EncryptedSessionKeys
 */
export type ProvisioningRequest_EncryptedSessionKeys =
    Message<'video_widevine.ProvisioningRequest.EncryptedSessionKeys'> & {
        /**
         * Serial number of certificate which was used to encrypt the session keys.
         * Required.
         *
         * @generated from field: optional bytes certificate_serial_number = 1;
         */
        certificateSerialNumber: Uint8Array

        /**
         * Serialized, encrypted session keys.  Required.
         *
         * @generated from field: optional bytes encrypted_session_keys = 2;
         */
        encryptedSessionKeys: Uint8Array
    }

/**
 * Describes the message video_widevine.ProvisioningRequest.EncryptedSessionKeys.
 * Use `create(ProvisioningRequest_EncryptedSessionKeysSchema)` to create a new message.
 */
export const ProvisioningRequest_EncryptedSessionKeysSchema: GenMessage<ProvisioningRequest_EncryptedSessionKeys> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 13, 0)

/**
 * @generated from message video_widevine.ProvisioningRequest.EncryptedSessionKeys.SessionKeys
 */
export type ProvisioningRequest_EncryptedSessionKeys_SessionKeys =
    Message<'video_widevine.ProvisioningRequest.EncryptedSessionKeys.SessionKeys'> & {
        /**
         * 16 bytes encryption key generated by client, used by the server to:
         * (1) AES-128-CBC decrypt encrypted_client_id in
         *     EncryptedClientIdentification which is in RemoteAttestation
         * (2) AES-128-CBC encrypt device_key to be returned in
         *     ProvisioningResponse.
         *
         * @generated from field: optional bytes encryption_key = 1;
         */
        encryptionKey: Uint8Array

        /**
         * 32 bytes mac key generated by client, used by server to sign
         * the ProvisioningResponse.
         *
         * @generated from field: optional bytes mac_key = 2;
         */
        macKey: Uint8Array
    }

/**
 * Describes the message video_widevine.ProvisioningRequest.EncryptedSessionKeys.SessionKeys.
 * Use `create(ProvisioningRequest_EncryptedSessionKeys_SessionKeysSchema)` to create a new message.
 */
export const ProvisioningRequest_EncryptedSessionKeys_SessionKeysSchema: GenMessage<ProvisioningRequest_EncryptedSessionKeys_SessionKeys> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 13, 0, 0)

/**
 * This message contains the custom serialized message for OTA provisioning
 * using Android Attestation and a device id as authentication.
 *
 * @generated from message video_widevine.ProvisioningRequest.AndroidAttestationOtaKeyboxRequest
 */
export type ProvisioningRequest_AndroidAttestationOtaKeyboxRequest =
    Message<'video_widevine.ProvisioningRequest.AndroidAttestationOtaKeyboxRequest'> & {
        /**
         * The request contains custom serialized and signed data for the
         * Android Attestation OTA request.
         * see: go/wv_android_ota
         *
         * @generated from field: optional bytes ota_request = 1;
         */
        otaRequest: Uint8Array
    }

/**
 * Describes the message video_widevine.ProvisioningRequest.AndroidAttestationOtaKeyboxRequest.
 * Use `create(ProvisioningRequest_AndroidAttestationOtaKeyboxRequestSchema)` to create a new message.
 */
export const ProvisioningRequest_AndroidAttestationOtaKeyboxRequestSchema: GenMessage<ProvisioningRequest_AndroidAttestationOtaKeyboxRequest> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 13, 1)

/**
 * Provisioning response sent by the provisioning server to client devices.
 * This message is used for both regular Widevine DRM certificates and for
 * application-specific X.509 certificates.
 *
 * @generated from message video_widevine.ProvisioningResponse
 */
export type ProvisioningResponse =
    Message<'video_widevine.ProvisioningResponse'> & {
        /**
         * AES-128 encrypted device private RSA key. PKCS#1 ASN.1 DER-encoded.
         * Required. For X.509 certificates, the private RSA key may also include
         * a prefix as specified by private_key_prefix in the X509CertificateMetadata
         * proto message.
         *
         * @generated from field: optional bytes device_rsa_key = 1;
         */
        deviceRsaKey: Uint8Array

        /**
         * Initialization vector used to encrypt device_rsa_key. Required.
         *
         * @generated from field: optional bytes device_rsa_key_iv = 2;
         */
        deviceRsaKeyIv: Uint8Array

        /**
         * For Widevine DRM certificates, this contains the serialized
         * SignedDrmCertificate. For X.509 certificates, this contains the PEM
         * encoded X.509 certificate. Required.
         *
         * @generated from field: optional bytes device_certificate = 3;
         */
        deviceCertificate: Uint8Array

        /**
         * Nonce value matching nonce in ProvisioningRequest. Required.
         *
         * @generated from field: optional bytes nonce = 4;
         */
        nonce: Uint8Array

        /**
         * Key used to wrap device_rsa_key when DRM provisioning an OEM factory
         * provisioned device. Encrypted with the device OEM public key using
         * RSA-OAEP.
         *
         * @generated from field: optional bytes wrapping_key = 5;
         */
        wrappingKey: Uint8Array

        /**
         * Only populated in OTA keybox provisioning response.
         *
         * @generated from field: optional video_widevine.ProvisioningResponse.OtaKeybox ota_keybox = 6;
         */
        otaKeybox?: ProvisioningResponse_OtaKeybox

        /**
         * The provisioning service may return a ProvisioningStatus. Fields other
         * than |status| may be empty and should be ignored if the |status|
         * is present and not NO_ERROR
         *
         * @generated from field: optional video_widevine.ProvisioningResponse.ProvisioningStatus status = 7;
         */
        status: ProvisioningResponse_ProvisioningStatus

        /**
         * The Android Attestation OTA response. Only populated if the request
         * was an Android Attestation OTA request.
         *
         * @generated from field: optional video_widevine.ProvisioningResponse.AndroidAttestationOtaKeyboxResponse android_ota_keybox_response = 8;
         */
        androidOtaKeyboxResponse?: ProvisioningResponse_AndroidAttestationOtaKeyboxResponse
    }

/**
 * Describes the message video_widevine.ProvisioningResponse.
 * Use `create(ProvisioningResponseSchema)` to create a new message.
 */
export const ProvisioningResponseSchema: GenMessage<ProvisioningResponse> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 14)

/**
 * @generated from message video_widevine.ProvisioningResponse.OtaKeybox
 */
export type ProvisioningResponse_OtaKeybox =
    Message<'video_widevine.ProvisioningResponse.OtaKeybox'> & {
        /**
         * Iv used along with SessionKeys.encryption_key for encrypting device key.
         *
         * @generated from field: optional bytes device_key_encryption_iv = 1;
         */
        deviceKeyEncryptionIv: Uint8Array

        /**
         * Device key component of the keybox, encrypted using the
         * SessionKeys.encryption_key in the request and |device_key_encryption_iv|
         * above.
         *
         * @generated from field: optional bytes encrypted_device_key = 2;
         */
        encryptedDeviceKey: Uint8Array

        /**
         * Device CA token component of the keybox.
         *
         * @generated from field: optional bytes device_ca_token = 3;
         */
        deviceCaToken: Uint8Array
    }

/**
 * Describes the message video_widevine.ProvisioningResponse.OtaKeybox.
 * Use `create(ProvisioningResponse_OtaKeyboxSchema)` to create a new message.
 */
export const ProvisioningResponse_OtaKeyboxSchema: GenMessage<ProvisioningResponse_OtaKeybox> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 14, 0)

/**
 * This message contains the custom response for Android Attestation OTA
 * provisioning which uses the Android Attestation keybox and a device id
 * from the chip set.
 *
 * @generated from message video_widevine.ProvisioningResponse.AndroidAttestationOtaKeyboxResponse
 */
export type ProvisioningResponse_AndroidAttestationOtaKeyboxResponse =
    Message<'video_widevine.ProvisioningResponse.AndroidAttestationOtaKeyboxResponse'> & {
        /**
         * The response contains custom serialized and signed data for the
         * Android Attestation OTA keybox provisioning.
         *
         * @generated from field: optional bytes ota_response = 1;
         */
        otaResponse: Uint8Array
    }

/**
 * Describes the message video_widevine.ProvisioningResponse.AndroidAttestationOtaKeyboxResponse.
 * Use `create(ProvisioningResponse_AndroidAttestationOtaKeyboxResponseSchema)` to create a new message.
 */
export const ProvisioningResponse_AndroidAttestationOtaKeyboxResponseSchema: GenMessage<ProvisioningResponse_AndroidAttestationOtaKeyboxResponse> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 14, 1)

/**
 * @generated from enum video_widevine.ProvisioningResponse.ProvisioningStatus
 */
export enum ProvisioningResponse_ProvisioningStatus {
    /**
     * Indicates a valid provisioning response
     *
     * @generated from enum value: NO_ERROR = 0;
     */
    NO_ERROR = 0,

    /**
     * The device credentials have been revoked. Provisioning is not possible.
     *
     * @generated from enum value: REVOKED_DEVICE_CREDENTIALS = 1;
     */
    REVOKED_DEVICE_CREDENTIALS = 1,

    /**
     * Devices in this series have been revoked. Provisioning is not possible.
     *
     * @generated from enum value: REVOKED_DEVICE_SERIES = 2;
     */
    REVOKED_DEVICE_SERIES = 2
}

/**
 * Describes the enum video_widevine.ProvisioningResponse.ProvisioningStatus.
 */
export const ProvisioningResponse_ProvisioningStatusSchema: GenEnum<ProvisioningResponse_ProvisioningStatus> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 14, 0)

/**
 * Protocol-specific context data used to hold the state of the server in
 * stateful provisioning protocols.
 *
 * @generated from message video_widevine.ProvisioningContext
 */
export type ProvisioningContext =
    Message<'video_widevine.ProvisioningContext'> & {
        /**
         * Serialized ProvisioningContextKeyData. Required.
         *
         * @generated from field: optional bytes key_data = 1;
         */
        keyData: Uint8Array

        /**
         * Protocol-dependent context data, encrypted with key and IV in key_data.
         * Required.
         *
         * @generated from field: optional bytes context_data = 2;
         */
        contextData: Uint8Array
    }

/**
 * Describes the message video_widevine.ProvisioningContext.
 * Use `create(ProvisioningContextSchema)` to create a new message.
 */
export const ProvisioningContextSchema: GenMessage<ProvisioningContext> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 15)

/**
 * @generated from message video_widevine.SignedProvisioningContext
 */
export type SignedProvisioningContext =
    Message<'video_widevine.SignedProvisioningContext'> & {
        /**
         * ProvisioningContext in bytes.
         *
         * @generated from field: optional bytes provisioning_context = 1;
         */
        provisioningContext: Uint8Array

        /**
         * RSASSA-PSS signature of provisioning_context. Signed with service private
         * key.
         *
         * @generated from field: optional bytes signature = 2;
         */
        signature: Uint8Array

        /**
         * Optional field that indicates the hash algorithm used in signature scheme.
         *
         * @generated from field: optional video_widevine.HashAlgorithmProto hash_algorithm = 3;
         */
        hashAlgorithm: HashAlgorithmProto
    }

/**
 * Describes the message video_widevine.SignedProvisioningContext.
 * Use `create(SignedProvisioningContextSchema)` to create a new message.
 */
export const SignedProvisioningContextSchema: GenMessage<SignedProvisioningContext> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 16)

/**
 * Cryptographic tokens to be used for ProvisioningContext.
 *
 * @generated from message video_widevine.ProvisioningContextKeyData
 */
export type ProvisioningContextKeyData =
    Message<'video_widevine.ProvisioningContextKeyData'> & {
        /**
         * Encryption key, usually 32 bytes used for AES-256-CBC. Required.
         *
         * @generated from field: optional bytes encryption_key = 1;
         */
        encryptionKey: Uint8Array

        /**
         * Encryption IV, 16 bytes. Required.
         *
         * @generated from field: optional bytes encryption_iv = 2;
         */
        encryptionIv: Uint8Array
    }

/**
 * Describes the message video_widevine.ProvisioningContextKeyData.
 * Use `create(ProvisioningContextKeyDataSchema)` to create a new message.
 */
export const ProvisioningContextKeyDataSchema: GenMessage<ProvisioningContextKeyData> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 17)

/**
 * Serialized ProvisioningRequest or ProvisioningResponse signed with
 * The message authentication key.
 *
 * @generated from message video_widevine.SignedProvisioningMessage
 */
export type SignedProvisioningMessage =
    Message<'video_widevine.SignedProvisioningMessage'> & {
        /**
         * Serialized protobuf message for the corresponding protocol and stage of
         * the provisioning exchange. ProvisioningRequest or ProvisioningResponse
         * in the case of Provisioning 2.0, 3.0, 4.0 and ARCPP_PROVISIONING. Required.
         *
         * @generated from field: optional bytes message = 1;
         */
        message: Uint8Array

        /**
         * HMAC-SHA256 (Keybox) or RSASSA-PSS (OEM) signature of message. Required
         * for provisioning 2.0 and 3.0. For ARCPP_PROVISIONING, only used in
         * response.
         *
         * @generated from field: optional bytes signature = 2;
         */
        signature: Uint8Array

        /**
         * Version number of provisioning protocol.
         *
         * @generated from field: optional video_widevine.SignedProvisioningMessage.ProvisioningType provisioning_type = 3 [default = PROVISIONING_20];
         */
        provisioningType: SignedProvisioningMessage_ProvisioningType

        /**
         * Protocol-specific context / state information for multiple-exchange,
         * stateful provisioning protocols.  Optional.
         *
         * @generated from field: optional video_widevine.SignedProvisioningContext signed_provisioning_context = 4;
         */
        signedProvisioningContext?: SignedProvisioningContext

        /**
         * Remote attestation data to authenticate that the ChromeOS client device
         * is operating in verified mode. Remote attestation challenge data is
         * |message| field above. Required for ARCPP_PROVISIONING request.
         * It contains signature of |message|.
         *
         * @generated from field: optional video_widevine.RemoteAttestation remote_attestation = 5;
         */
        remoteAttestation?: RemoteAttestation

        /**
         * The core message is the simple serialization of fields used by OEMCrypto.
         * This field was introduced in OEMCrypto API v16. The core message format is
         * documented in the "Widevine Core Message Serialization".
         *
         * @generated from field: optional bytes oemcrypto_core_message = 6;
         */
        oemcryptoCoreMessage: Uint8Array

        /**
         * Optional field that indicates the hash algorithm used in signature scheme.
         *
         * @generated from field: optional video_widevine.HashAlgorithmProto hash_algorithm = 7;
         */
        hashAlgorithm: HashAlgorithmProto

        /**
         * Indicates which version of the protocol is in use.
         *
         * @generated from field: optional video_widevine.SignedProvisioningMessage.ProvisioningProtocolVersion protocol_version = 8;
         */
        protocolVersion: SignedProvisioningMessage_ProvisioningProtocolVersion

        /**
         * If populated, the contents of this field will be signaled by the
         * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
         * key is the bytes of an encrypted AES key. If the |session_key_type| is
         * EPHEMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
         * serialized ECC public key.
         * This field is only required to be set in a success response to
         * Provisioning 4.0 X509 (cast) certificate request.
         *
         * @generated from field: optional bytes session_key = 9;
         */
        sessionKey: Uint8Array

        /**
         * Optional field that contains the algorithm type used to generate the
         * session_key and signature in a ProvisioningResponse message. This value is
         * populated in a success response to a request for a X509 (cast) certificate.
         * The value used depends on the key type of the PublicKeyToCertify contained
         * in Provisioning 4.0 ProvisioningMessage.
         * This value must be populated if session_key is populated.
         *
         * @generated from field: optional video_widevine.SignedProvisioningMessage.SessionKeyType session_key_type = 10;
         */
        sessionKeyType: SignedProvisioningMessage_SessionKeyType
    }

/**
 * Describes the message video_widevine.SignedProvisioningMessage.
 * Use `create(SignedProvisioningMessageSchema)` to create a new message.
 */
export const SignedProvisioningMessageSchema: GenMessage<SignedProvisioningMessage> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 18)

/**
 * @generated from enum video_widevine.SignedProvisioningMessage.ProvisioningProtocolVersion
 */
export enum SignedProvisioningMessage_ProvisioningProtocolVersion {
    /**
     * @generated from enum value: VERSION_UNSPECIFIED = 0;
     */
    VERSION_UNSPECIFIED = 0,

    /**
     * @generated from enum value: VERSION_1 = 1;
     */
    VERSION_1 = 1,

    /**
     * Version 1.1 changed error handling. Some errors are returned as a field
     * in a response message rather than being handled as errors via the API
     * implementation. E.g. embedded in the ProvisioningResponse rather than
     * returning a 400 error to the caller.
     *
     * @generated from enum value: VERSION_1_1 = 2;
     */
    VERSION_1_1 = 2
}

/**
 * Describes the enum video_widevine.SignedProvisioningMessage.ProvisioningProtocolVersion.
 */
export const SignedProvisioningMessage_ProvisioningProtocolVersionSchema: GenEnum<SignedProvisioningMessage_ProvisioningProtocolVersion> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 18, 0)

/**
 * This enum was renamed to avoid confusion
 *
 * @generated from enum video_widevine.SignedProvisioningMessage.ProvisioningType
 */
export enum SignedProvisioningMessage_ProvisioningType {
    /**
     * @generated from enum value: PROVISIONING_TYPE_UNSPECIFIED = 0;
     */
    PROVISIONING_TYPE_UNSPECIFIED = 0,

    /**
     * Service certificate request.
     *
     * @generated from enum value: SERVICE_CERTIFICATE_REQUEST = 1;
     */
    SERVICE_CERTIFICATE_REQUEST = 1,

    /**
     * Keybox factory-provisioned devices.
     *
     * @generated from enum value: PROVISIONING_20 = 2;
     */
    PROVISIONING_20 = 2,

    /**
     * OEM certificate factory-provisioned devices.
     *
     * @generated from enum value: PROVISIONING_30 = 3;
     */
    PROVISIONING_30 = 3,

    /**
     * Devices use Boot Certificate Chain (BCC) to provision an OEM certificate.
     *
     * @generated from enum value: PROVISIONING_40 = 5;
     */
    PROVISIONING_40 = 5,

    /**
     * These are provisioning methods that are only supported by internal
     * Widevine services. They should not be exposed in the SDK.
     *
     * ChromeOS/Arc++ devices.
     *
     * @generated from enum value: ARCPP_PROVISIONING = 4;
     */
    ARCPP_PROVISIONING = 4,

    /**
     * Android-Attestation-based OTA keyboxes.
     *
     * @generated from enum value: ANDROID_ATTESTATION_KEYBOX_OTA = 6;
     */
    ANDROID_ATTESTATION_KEYBOX_OTA = 6,

    /**
     * DRM certificate reprovisioning for individualization of embedded
     * DRM certificates used by internal L3 CDMs only.
     *
     * @generated from enum value: DRM_REPROVISIONING = 7;
     */
    DRM_REPROVISIONING = 7,

    /**
     * Intel Sigma 1.0.1 protocol.
     *
     * @generated from enum value: INTEL_SIGMA_101 = 101;
     */
    INTEL_SIGMA_101 = 101,

    /**
     * Intel Sigma 2.1.0 protocol.
     *
     * @generated from enum value: INTEL_SIGMA_210 = 210;
     */
    INTEL_SIGMA_210 = 210
}

/**
 * Describes the enum video_widevine.SignedProvisioningMessage.ProvisioningType.
 */
export const SignedProvisioningMessage_ProvisioningTypeSchema: GenEnum<SignedProvisioningMessage_ProvisioningType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 18, 1)

/**
 * Used by provisioning 4.0 to deliver cast certificates in which the server
 * delivers a new rsa private key that must be encrypted and signed.
 *
 * @generated from enum video_widevine.SignedProvisioningMessage.SessionKeyType
 */
export enum SignedProvisioningMessage_SessionKeyType {
    /**
     * @generated from enum value: UNDEFINED = 0;
     */
    UNDEFINED = 0,

    /**
     * @generated from enum value: WRAPPED_AES_KEY = 1;
     */
    WRAPPED_AES_KEY = 1,

    /**
     * @generated from enum value: EPHEMERAL_ECC_PUBLIC_KEY = 2;
     */
    EPHEMERAL_ECC_PUBLIC_KEY = 2
}

/**
 * Describes the enum video_widevine.SignedProvisioningMessage.SessionKeyType.
 */
export const SignedProvisioningMessage_SessionKeyTypeSchema: GenEnum<SignedProvisioningMessage_SessionKeyType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 18, 2)

/**
 * ClientIdentification message used to authenticate the client device.
 *
 * @generated from message video_widevine.ClientIdentification
 */
export type ClientIdentification =
    Message<'video_widevine.ClientIdentification'> & {
        /**
         * Type of factory-provisioned device root of trust. Optional.
         *
         * @generated from field: optional video_widevine.ClientIdentification.TokenType type = 1 [default = KEYBOX];
         */
        type: ClientIdentification_TokenType

        /**
         * Factory-provisioned device root of trust. Required.
         *
         * @generated from field: optional bytes token = 2;
         */
        token: Uint8Array

        /**
         * Optional client information name/value pairs.
         *
         * @generated from field: repeated video_widevine.ClientIdentification.NameValue client_info = 3;
         */
        clientInfo: ClientIdentification_NameValue[]

        /**
         * Client token generated by the content provider. Optional.
         *
         * @generated from field: optional bytes provider_client_token = 4;
         */
        providerClientToken: Uint8Array

        /**
         * Number of licenses received by the client to which the token above belongs.
         * Only present if client_token is specified.
         *
         * @generated from field: optional uint32 license_counter = 5;
         */
        licenseCounter: number

        /**
         * List of non-baseline client capabilities.
         *
         * @generated from field: optional video_widevine.ClientIdentification.ClientCapabilities client_capabilities = 6;
         */
        clientCapabilities?: ClientIdentification_ClientCapabilities

        /**
         * Serialized VmpData message. Optional.
         *
         * @generated from field: optional bytes vmp_data = 7;
         */
        vmpData: Uint8Array

        /**
         * Optional field that may contain additional provisioning credentials.
         *
         * @generated from field: optional video_widevine.ClientIdentification.ClientCredentials device_credentials = 8;
         */
        deviceCredentials?: ClientIdentification_ClientCredentials
    }

/**
 * Describes the message video_widevine.ClientIdentification.
 * Use `create(ClientIdentificationSchema)` to create a new message.
 */
export const ClientIdentificationSchema: GenMessage<ClientIdentification> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 19)

/**
 * @generated from message video_widevine.ClientIdentification.NameValue
 */
export type ClientIdentification_NameValue =
    Message<'video_widevine.ClientIdentification.NameValue'> & {
        /**
         * @generated from field: optional string name = 1;
         */
        name: string

        /**
         * @generated from field: optional string value = 2;
         */
        value: string
    }

/**
 * Describes the message video_widevine.ClientIdentification.NameValue.
 * Use `create(ClientIdentification_NameValueSchema)` to create a new message.
 */
export const ClientIdentification_NameValueSchema: GenMessage<ClientIdentification_NameValue> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 19, 0)

/**
 * Capabilities which not all clients may support. Used for the license
 * exchange protocol only.
 *
 * @generated from message video_widevine.ClientIdentification.ClientCapabilities
 */
export type ClientIdentification_ClientCapabilities =
    Message<'video_widevine.ClientIdentification.ClientCapabilities'> & {
        /**
         * @generated from field: optional bool client_token = 1 [default = false];
         */
        clientToken: boolean

        /**
         * @generated from field: optional bool session_token = 2 [default = false];
         */
        sessionToken: boolean

        /**
         * @generated from field: optional bool video_resolution_constraints = 3 [default = false];
         */
        videoResolutionConstraints: boolean

        /**
         * @generated from field: optional video_widevine.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];
         */
        maxHdcpVersion: ClientIdentification_ClientCapabilities_HdcpVersion

        /**
         * @generated from field: optional uint32 oem_crypto_api_version = 5;
         */
        oemCryptoApiVersion: number

        /**
         * Client has hardware support for protecting the usage table, such as
         * storing the generation number in secure memory.
         *
         * @generated from field: optional bool anti_rollback_usage_table = 6 [default = false];
         */
        antiRollbackUsageTable: boolean

        /**
         * The client shall report |srm_version| if available.
         *
         * @generated from field: optional uint32 srm_version = 7;
         */
        srmVersion: number

        /**
         * A device may have SRM data, and report a version, but may not be capable
         * of updating SRM data.
         *
         * @generated from field: optional bool can_update_srm = 8 [default = false];
         */
        canUpdateSrm: boolean

        /**
         * @generated from field: repeated video_widevine.ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;
         */
        supportedCertificateKeyType: ClientIdentification_ClientCapabilities_CertificateKeyType[]

        /**
         * @generated from field: optional video_widevine.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];
         */
        analogOutputCapabilities: ClientIdentification_ClientCapabilities_AnalogOutputCapabilities

        /**
         * @generated from field: optional bool can_disable_analog_output = 11 [default = false];
         */
        canDisableAnalogOutput: boolean

        /**
         * Clients can indicate a performance level supported by OEMCrypto.
         * This will allow applications and providers to choose an appropriate
         * quality of content to serve. Currently defined tiers are
         * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
         * the resource rating is unavailable or reporting erroneous values
         * for that device.
         *
         * @generated from field: optional uint32 resource_rating_tier = 12 [default = 0];
         */
        resourceRatingTier: number

        /**
         * Watermarking support of OEMCrypto was introduced in v17.
         * Support is optional.
         * Value is only required to be set for license requests.
         *
         * @generated from field: optional video_widevine.ClientIdentification.ClientCapabilities.WatermarkingSupport watermarking_support = 13;
         */
        watermarkingSupport: ClientIdentification_ClientCapabilities_WatermarkingSupport

        /**
         * Indicate whether or not `initial_renewal_delay_base` is supported by the
         * client.
         *
         * @generated from field: optional bool initial_renewal_delay_base = 14 [default = false];
         */
        initialRenewalDelayBase: boolean
    }

/**
 * Describes the message video_widevine.ClientIdentification.ClientCapabilities.
 * Use `create(ClientIdentification_ClientCapabilitiesSchema)` to create a new message.
 */
export const ClientIdentification_ClientCapabilitiesSchema: GenMessage<ClientIdentification_ClientCapabilities> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 19, 1)

/**
 * @generated from enum video_widevine.ClientIdentification.ClientCapabilities.HdcpVersion
 */
export enum ClientIdentification_ClientCapabilities_HdcpVersion {
    /**
     * @generated from enum value: HDCP_NONE = 0;
     */
    HDCP_NONE = 0,

    /**
     * @generated from enum value: HDCP_V1 = 1;
     */
    HDCP_V1 = 1,

    /**
     * @generated from enum value: HDCP_V2 = 2;
     */
    HDCP_V2 = 2,

    /**
     * @generated from enum value: HDCP_V2_1 = 3;
     */
    HDCP_V2_1 = 3,

    /**
     * @generated from enum value: HDCP_V2_2 = 4;
     */
    HDCP_V2_2 = 4,

    /**
     * @generated from enum value: HDCP_V2_3 = 5;
     */
    HDCP_V2_3 = 5,

    /**
     * The existing HDCP_V1 will be used for backwards compatibility with pre
     * OEM crypto v17.
     *
     * @generated from enum value: HDCP_V1_0 = 6;
     */
    HDCP_V1_0 = 6,

    /**
     * @generated from enum value: HDCP_V1_1 = 7;
     */
    HDCP_V1_1 = 7,

    /**
     * @generated from enum value: HDCP_V1_2 = 8;
     */
    HDCP_V1_2 = 8,

    /**
     * @generated from enum value: HDCP_V1_3 = 9;
     */
    HDCP_V1_3 = 9,

    /**
     * @generated from enum value: HDCP_V1_4 = 10;
     */
    HDCP_V1_4 = 10,

    /**
     * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
     */
    HDCP_NO_DIGITAL_OUTPUT = 255
}

/**
 * Describes the enum video_widevine.ClientIdentification.ClientCapabilities.HdcpVersion.
 */
export const ClientIdentification_ClientCapabilities_HdcpVersionSchema: GenEnum<ClientIdentification_ClientCapabilities_HdcpVersion> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 19, 1, 0)

/**
 * @generated from enum video_widevine.ClientIdentification.ClientCapabilities.CertificateKeyType
 */
export enum ClientIdentification_ClientCapabilities_CertificateKeyType {
    /**
     * @generated from enum value: RSA_2048 = 0;
     */
    RSA_2048 = 0,

    /**
     * @generated from enum value: RSA_3072 = 1;
     */
    RSA_3072 = 1,

    /**
     * @generated from enum value: ECC_SECP256R1 = 2;
     */
    ECC_SECP256R1 = 2,

    /**
     * @generated from enum value: ECC_SECP384R1 = 3;
     */
    ECC_SECP384R1 = 3,

    /**
     * @generated from enum value: ECC_SECP521R1 = 4;
     */
    ECC_SECP521R1 = 4
}

/**
 * Describes the enum video_widevine.ClientIdentification.ClientCapabilities.CertificateKeyType.
 */
export const ClientIdentification_ClientCapabilities_CertificateKeyTypeSchema: GenEnum<ClientIdentification_ClientCapabilities_CertificateKeyType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 19, 1, 1)

/**
 * @generated from enum video_widevine.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities
 */
export enum ClientIdentification_ClientCapabilities_AnalogOutputCapabilities {
    /**
     * @generated from enum value: ANALOG_OUTPUT_UNKNOWN = 0;
     */
    ANALOG_OUTPUT_UNKNOWN = 0,

    /**
     * @generated from enum value: ANALOG_OUTPUT_NONE = 1;
     */
    ANALOG_OUTPUT_NONE = 1,

    /**
     * @generated from enum value: ANALOG_OUTPUT_SUPPORTED = 2;
     */
    ANALOG_OUTPUT_SUPPORTED = 2,

    /**
     * @generated from enum value: ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3;
     */
    ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3
}

/**
 * Describes the enum video_widevine.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities.
 */
export const ClientIdentification_ClientCapabilities_AnalogOutputCapabilitiesSchema: GenEnum<ClientIdentification_ClientCapabilities_AnalogOutputCapabilities> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 19, 1, 2)

/**
 * @generated from enum video_widevine.ClientIdentification.ClientCapabilities.WatermarkingSupport
 */
export enum ClientIdentification_ClientCapabilities_WatermarkingSupport {
    /**
     * @generated from enum value: WATERMARKING_SUPPORT_UNKNOWN = 0;
     */
    WATERMARKING_SUPPORT_UNKNOWN = 0,

    /**
     * @generated from enum value: WATERMARKING_NOT_SUPPORTED = 1;
     */
    WATERMARKING_NOT_SUPPORTED = 1,

    /**
     * @generated from enum value: WATERMARKING_CONFIGURABLE = 2;
     */
    WATERMARKING_CONFIGURABLE = 2,

    /**
     * @generated from enum value: WATERMARKING_ALWAYS_ON = 3;
     */
    WATERMARKING_ALWAYS_ON = 3
}

/**
 * Describes the enum video_widevine.ClientIdentification.ClientCapabilities.WatermarkingSupport.
 */
export const ClientIdentification_ClientCapabilities_WatermarkingSupportSchema: GenEnum<ClientIdentification_ClientCapabilities_WatermarkingSupport> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 19, 1, 3)

/**
 * @generated from message video_widevine.ClientIdentification.ClientCredentials
 */
export type ClientIdentification_ClientCredentials =
    Message<'video_widevine.ClientIdentification.ClientCredentials'> & {
        /**
         * @generated from field: optional video_widevine.ClientIdentification.TokenType type = 1 [default = KEYBOX];
         */
        type: ClientIdentification_TokenType

        /**
         * @generated from field: optional bytes token = 2;
         */
        token: Uint8Array
    }

/**
 * Describes the message video_widevine.ClientIdentification.ClientCredentials.
 * Use `create(ClientIdentification_ClientCredentialsSchema)` to create a new message.
 */
export const ClientIdentification_ClientCredentialsSchema: GenMessage<ClientIdentification_ClientCredentials> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 19, 2)

/**
 * @generated from enum video_widevine.ClientIdentification.TokenType
 */
export enum ClientIdentification_TokenType {
    /**
     * @generated from enum value: KEYBOX = 0;
     */
    KEYBOX = 0,

    /**
     * @generated from enum value: DRM_DEVICE_CERTIFICATE = 1;
     */
    DRM_DEVICE_CERTIFICATE = 1,

    /**
     * @generated from enum value: REMOTE_ATTESTATION_CERTIFICATE = 2;
     */
    REMOTE_ATTESTATION_CERTIFICATE = 2,

    /**
     * @generated from enum value: OEM_DEVICE_CERTIFICATE = 3;
     */
    OEM_DEVICE_CERTIFICATE = 3,

    /**
     * Boot certificate chain in CBOR format.
     *
     * @generated from enum value: BOOT_CERTIFICATE_CHAIN = 4;
     */
    BOOT_CERTIFICATE_CHAIN = 4,

    /**
     * Boot certificate chain in X509 format.
     *
     * @generated from enum value: BOOT_CERTIFICATE_CHAIN_X509 = 5;
     */
    BOOT_CERTIFICATE_CHAIN_X509 = 5
}

/**
 * Describes the enum video_widevine.ClientIdentification.TokenType.
 */
export const ClientIdentification_TokenTypeSchema: GenEnum<ClientIdentification_TokenType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 19, 0)

/**
 * EncryptedClientIdentification message used to hold ClientIdentification
 * messages encrypted for privacy purposes.
 *
 * @generated from message video_widevine.EncryptedClientIdentification
 */
export type EncryptedClientIdentification =
    Message<'video_widevine.EncryptedClientIdentification'> & {
        /**
         * Provider ID for which the ClientIdentifcation is encrypted (owner of
         * service certificate).
         *
         * @generated from field: optional string provider_id = 1;
         */
        providerId: string

        /**
         * Serial number for the service certificate for which ClientIdentification is
         * encrypted.
         *
         * @generated from field: optional bytes service_certificate_serial_number = 2;
         */
        serviceCertificateSerialNumber: Uint8Array

        /**
         * Serialized ClientIdentification message, encrypted with the privacy key
         * using AES-128-CBC with PKCS#5 padding.
         *
         * @generated from field: optional bytes encrypted_client_id = 3;
         */
        encryptedClientId: Uint8Array

        /**
         * Initialization vector needed to decrypt encrypted_client_id.
         *
         * @generated from field: optional bytes encrypted_client_id_iv = 4;
         */
        encryptedClientIdIv: Uint8Array

        /**
         * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
         *
         * @generated from field: optional bytes encrypted_privacy_key = 5;
         */
        encryptedPrivacyKey: Uint8Array
    }

/**
 * Describes the message video_widevine.EncryptedClientIdentification.
 * Use `create(EncryptedClientIdentificationSchema)` to create a new message.
 */
export const EncryptedClientIdentificationSchema: GenMessage<EncryptedClientIdentification> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 20)

/**
 * ----------------------------------------------------------------------------
 * drm_certificate.proto
 * ----------------------------------------------------------------------------
 * Description of section:
 * Definition of the root of trust identifier proto. The proto message contains
 * the EC-IES encrypted identifier (e.g. keybox unique id) for a device and
 * an associated hash. These can be used by Widevine to identify the root of
 * trust that was used to acquire a DRM certificate.
 *
 * In addition to the encrypted part and the hash, the proto contains the
 * version of the root of trust id which implies the EC key algorithm that was
 * used.
 * Next id: 5
 *
 * @generated from message video_widevine.RootOfTrustId
 */
export type RootOfTrustId = Message<'video_widevine.RootOfTrustId'> & {
    /**
     * @generated from field: optional video_widevine.RootOfTrustId.RootOfTrustIdVersion version = 1;
     */
    version: RootOfTrustId_RootOfTrustIdVersion

    /**
     * The key_id is used for key rotation. It indicates which key was used to
     * generate the root of trust id.
     *
     * @generated from field: optional uint32 key_id = 2;
     */
    keyId: number

    /**
     * The EC-IES encrypted message containing the unique_id. The bytes are
     * a concatenation of
     *    1) The ephemeral public key. Uncompressed keypoint format per X9.62.
     *    2) The plaintext encrypted with the derived AES key using AES CBC,
     *       PKCS7 padding and a zerio iv.
     *    3) The HMAC SHA256 of the cipher text.
     *
     * @generated from field: optional bytes encrypted_unique_id = 3;
     */
    encryptedUniqueId: Uint8Array

    /**
     * The hash of encrypted unique id and other values.
     * unique_id_hash = SHA256(
     *   encrypted_unique_id || system_id || SHA256(unique_id || secret_sauce)).
     *
     * @generated from field: optional bytes unique_id_hash = 4;
     */
    uniqueIdHash: Uint8Array
}

/**
 * Describes the message video_widevine.RootOfTrustId.
 * Use `create(RootOfTrustIdSchema)` to create a new message.
 */
export const RootOfTrustIdSchema: GenMessage<RootOfTrustId> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 21)

/**
 * The version specifies the EC algorithm that was used to generate the
 * root of trust id.
 *
 * @generated from enum video_widevine.RootOfTrustId.RootOfTrustIdVersion
 */
export enum RootOfTrustId_RootOfTrustIdVersion {
    /**
     * Should not be used.
     *
     * @generated from enum value: ROOT_OF_TRUST_ID_VERSION_UNSPECIFIED = 0;
     */
    ROOT_OF_TRUST_ID_VERSION_UNSPECIFIED = 0,

    /**
     * Version 1 of the ID uses EC-IES with SECP256R1 curve.
     *
     * @generated from enum value: ROOT_OF_TRUST_ID_VERSION_1 = 1;
     */
    ROOT_OF_TRUST_ID_VERSION_1 = 1
}

/**
 * Describes the enum video_widevine.RootOfTrustId.RootOfTrustIdVersion.
 */
export const RootOfTrustId_RootOfTrustIdVersionSchema: GenEnum<RootOfTrustId_RootOfTrustIdVersion> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 21, 0)

/**
 * DRM certificate definition for user devices, intermediate, service, and root
 * certificates.
 * Next id: 13
 *
 * @generated from message video_widevine.DrmCertificate
 */
export type DrmCertificate = Message<'video_widevine.DrmCertificate'> & {
    /**
     * Type of certificate. Required.
     *
     * @generated from field: optional video_widevine.DrmCertificate.Type type = 1;
     */
    type: DrmCertificate_Type

    /**
     * 128-bit globally unique serial number of certificate.
     * Value is 0 for root certificate. Required.
     *
     * @generated from field: optional bytes serial_number = 2;
     */
    serialNumber: Uint8Array

    /**
     * POSIX time, in seconds, when the certificate was created. Required.
     *
     * @generated from field: optional uint32 creation_time_seconds = 3;
     */
    creationTimeSeconds: number

    /**
     * POSIX time, in seconds, when the certificate should expire. Value of zero
     * denotes indefinite expiry time. For more information on limited lifespan
     * DRM certificates see (go/limited-lifespan-drm-certificates).
     *
     * @generated from field: optional uint32 expiration_time_seconds = 12;
     */
    expirationTimeSeconds: number

    /**
     * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
     *
     * @generated from field: optional bytes public_key = 4;
     */
    publicKey: Uint8Array

    /**
     * Widevine system ID for the device. Required for intermediate and
     * user device certificates.
     *
     * @generated from field: optional uint32 system_id = 5;
     */
    systemId: number

    /**
     * Deprecated field, which used to indicate whether the device was a test
     * (non-production) device. The test_device field in ProvisionedDeviceInfo
     * below should be observed instead.
     *
     * @generated from field: optional bool test_device_deprecated = 6 [deprecated = true];
     * @deprecated
     */
    testDeviceDeprecated: boolean

    /**
     * Service identifier (web origin) for the provider which owns the
     * certificate. Required for service and provisioner certificates.
     *
     * @generated from field: optional string provider_id = 7;
     */
    providerId: string

    /**
     * This field is used only when type = SERVICE to specify which SDK uses
     * service certificate. This repeated field is treated as a set. A certificate
     * may be used for the specified service SDK if the appropriate ServiceType
     * is specified in this field.
     *
     * @generated from field: repeated video_widevine.DrmCertificate.ServiceType service_types = 8;
     */
    serviceTypes: DrmCertificate_ServiceType[]

    /**
     * Required. The algorithm field contains the curve used to create the
     * |public_key| if algorithm is one of the ECC types.
     * The |algorithm| is used for both to determine the if the certificate is ECC
     * or RSA. The |algorithm| also specifies the parameters that were used to
     * create |public_key| and are used to create an ephemeral session key.
     *
     * @generated from field: optional video_widevine.DrmCertificate.Algorithm algorithm = 9 [default = RSA];
     */
    algorithm: DrmCertificate_Algorithm

    /**
     * Optional. May be present in DEVICE certificate types. This is the root
     * of trust identifier that holds an encrypted value that identifies the
     * keybox or other root of trust that was used to provision a DEVICE drm
     * certificate.
     *
     * @generated from field: optional video_widevine.RootOfTrustId rot_id = 10;
     */
    rotId?: RootOfTrustId

    /**
     * Optional. May be present in devices that explicitly support dual keys. When
     * present the |public_key| is used for verification of received license
     * request messages.
     *
     * @generated from field: optional video_widevine.DrmCertificate.EncryptionKey encryption_key = 11;
     */
    encryptionKey?: DrmCertificate_EncryptionKey
}

/**
 * Describes the message video_widevine.DrmCertificate.
 * Use `create(DrmCertificateSchema)` to create a new message.
 */
export const DrmCertificateSchema: GenMessage<DrmCertificate> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 22)

/**
 * @generated from message video_widevine.DrmCertificate.EncryptionKey
 */
export type DrmCertificate_EncryptionKey =
    Message<'video_widevine.DrmCertificate.EncryptionKey'> & {
        /**
         * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
         *
         * @generated from field: optional bytes public_key = 1;
         */
        publicKey: Uint8Array

        /**
         * Required. The algorithm field contains the curve used to create the
         * |public_key| if algorithm is one of the ECC types.
         * The |algorithm| is used for both to determine the if the certificate is
         * ECC or RSA. The |algorithm| also specifies the parameters that were used
         * to create |public_key| and are used to create an ephemeral session key.
         *
         * @generated from field: optional video_widevine.DrmCertificate.Algorithm algorithm = 2 [default = RSA];
         */
        algorithm: DrmCertificate_Algorithm
    }

/**
 * Describes the message video_widevine.DrmCertificate.EncryptionKey.
 * Use `create(DrmCertificate_EncryptionKeySchema)` to create a new message.
 */
export const DrmCertificate_EncryptionKeySchema: GenMessage<DrmCertificate_EncryptionKey> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 22, 0)

/**
 * @generated from enum video_widevine.DrmCertificate.Type
 */
export enum DrmCertificate_Type {
    /**
     * ProtoBestPractices: ignore.
     *
     * @generated from enum value: ROOT = 0;
     */
    ROOT = 0,

    /**
     * @generated from enum value: DEVICE_MODEL = 1;
     */
    DEVICE_MODEL = 1,

    /**
     * @generated from enum value: DEVICE = 2;
     */
    DEVICE = 2,

    /**
     * @generated from enum value: SERVICE = 3;
     */
    SERVICE = 3,

    /**
     * @generated from enum value: PROVISIONER = 4;
     */
    PROVISIONER = 4,

    /**
     * Only used by internal L3 CDMs with baked-in (embedded) certificates that
     * support the Drm Reprovisioning method for individualization of embedded
     * certificates.
     *
     * @generated from enum value: DEVICE_EMBEDDED = 5;
     */
    DEVICE_EMBEDDED = 5
}

/**
 * Describes the enum video_widevine.DrmCertificate.Type.
 */
export const DrmCertificate_TypeSchema: GenEnum<DrmCertificate_Type> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 22, 0)

/**
 * @generated from enum video_widevine.DrmCertificate.ServiceType
 */
export enum DrmCertificate_ServiceType {
    /**
     * @generated from enum value: UNKNOWN_SERVICE_TYPE = 0;
     */
    UNKNOWN_SERVICE_TYPE = 0,

    /**
     * @generated from enum value: LICENSE_SERVER_SDK = 1;
     */
    LICENSE_SERVER_SDK = 1,

    /**
     * @generated from enum value: LICENSE_SERVER_PROXY_SDK = 2;
     */
    LICENSE_SERVER_PROXY_SDK = 2,

    /**
     * @generated from enum value: PROVISIONING_SDK = 3;
     */
    PROVISIONING_SDK = 3,

    /**
     * @generated from enum value: CAS_PROXY_SDK = 4;
     */
    CAS_PROXY_SDK = 4
}

/**
 * Describes the enum video_widevine.DrmCertificate.ServiceType.
 */
export const DrmCertificate_ServiceTypeSchema: GenEnum<DrmCertificate_ServiceType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 22, 1)

/**
 * @generated from enum video_widevine.DrmCertificate.Algorithm
 */
export enum DrmCertificate_Algorithm {
    /**
     * @generated from enum value: UNKNOWN_ALGORITHM = 0;
     */
    UNKNOWN_ALGORITHM = 0,

    /**
     * @generated from enum value: RSA = 1;
     */
    RSA = 1,

    /**
     * @generated from enum value: ECC_SECP256R1 = 2;
     */
    ECC_SECP256R1 = 2,

    /**
     * @generated from enum value: ECC_SECP384R1 = 3;
     */
    ECC_SECP384R1 = 3,

    /**
     * @generated from enum value: ECC_SECP521R1 = 4;
     */
    ECC_SECP521R1 = 4
}

/**
 * Describes the enum video_widevine.DrmCertificate.Algorithm.
 */
export const DrmCertificate_AlgorithmSchema: GenEnum<DrmCertificate_Algorithm> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 22, 2)

/**
 * DrmCertificate signed by a higher (CA) DRM certificate.
 *
 * @generated from message video_widevine.SignedDrmCertificate
 */
export type SignedDrmCertificate =
    Message<'video_widevine.SignedDrmCertificate'> & {
        /**
         * Serialized certificate. Required.
         *
         * @generated from field: optional bytes drm_certificate = 1;
         */
        drmCertificate: Uint8Array

        /**
         * Signature of certificate. Signed with root or intermediate
         * certificate specified below. Required.
         *
         * @generated from field: optional bytes signature = 2;
         */
        signature: Uint8Array

        /**
         * SignedDrmCertificate used to sign this certificate.
         *
         * @generated from field: optional video_widevine.SignedDrmCertificate signer = 3;
         */
        signer?: SignedDrmCertificate

        /**
         * Optional field that indicates the hash algorithm used in signature scheme.
         *
         * @generated from field: optional video_widevine.HashAlgorithmProto hash_algorithm = 4;
         */
        hashAlgorithm: HashAlgorithmProto
    }

/**
 * Describes the message video_widevine.SignedDrmCertificate.
 * Use `create(SignedDrmCertificateSchema)` to create a new message.
 */
export const SignedDrmCertificateSchema: GenMessage<SignedDrmCertificate> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 23)

/**
 * @generated from message video_widevine.WidevinePsshData
 */
export type WidevinePsshData = Message<'video_widevine.WidevinePsshData'> & {
    /**
     * Entitlement or content key IDs. Can only present in SINGLE or ENTITLEMENT
     * PSSHs. May be repeated to facilitate delivery of multiple keys in a
     * single license. Cannot be used in conjunction with content_id or
     * group_ids, which are the preferred mechanism.
     *
     * @generated from field: repeated bytes key_ids = 2;
     */
    keyIds: Uint8Array[]

    /**
     * Content identifier which may map to multiple entitlement or content key
     * IDs to facilitate the delivery of multiple keys in a single license.
     * Cannot be present in conjunction with key_ids, but if used must be in all
     * PSSHs.
     *
     * @generated from field: optional bytes content_id = 4;
     */
    contentId: Uint8Array

    /**
     * Crypto period index, for media using key rotation. Always corresponds to
     * The content key period. This means that if using entitlement licensing
     * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
     * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
     * key rotation.
     *
     * @generated from field: optional uint32 crypto_period_index = 7;
     */
    cryptoPeriodIndex: number

    /**
     * Protection scheme identifying the encryption algorithm. The protection
     * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
     * representing a single ascii character in one of the 4CC protection scheme
     * values. To be deprecated in favor of signaling from content.
     * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
     * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
     * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
     * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
     *
     * @generated from field: optional uint32 protection_scheme = 9;
     */
    protectionScheme: number

    /**
     * Optional. For media using key rotation, this represents the duration
     * of each crypto period in seconds.
     *
     * @generated from field: optional uint32 crypto_period_seconds = 10;
     */
    cryptoPeriodSeconds: number

    /**
     * Type of PSSH. Required if not SINGLE.
     *
     * @generated from field: optional video_widevine.WidevinePsshData.Type type = 11 [default = SINGLE];
     */
    type: WidevinePsshData_Type

    /**
     * Key sequence for Widevine-managed keys. Optional.
     *
     * @generated from field: optional uint32 key_sequence = 12;
     */
    keySequence: number

    /**
     * Group identifiers for all groups to which the content belongs. This can
     * be used to deliver licenses to unlock multiple titles / channels.
     * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs,
     * and not in conjunction with key_ids.
     *
     * @generated from field: repeated bytes group_ids = 13;
     */
    groupIds: Uint8Array[]

    /**
     * Copy/copies of the content key used to decrypt the media stream in which
     * the PSSH box is embedded, each wrapped with a different entitlement key.
     * May also contain sub-licenses to support devices with OEMCrypto 13 or
     * older. May be repeated if using group entitlement keys. Present only in
     * PSSHs of type ENTITLED_KEY.
     *
     * @generated from field: repeated video_widevine.WidevinePsshData.EntitledKey entitled_keys = 14;
     */
    entitledKeys: WidevinePsshData_EntitledKey[]

    /**
     * Video feature identifier, which is used in conjunction with |content_id|
     * to determine the set of keys to be returned in the license. Cannot be
     * present in conjunction with |key_ids|.
     * Current values are "HDR".
     *
     * @generated from field: optional string video_feature = 15;
     */
    videoFeature: string

    /**
     * Audiofeature identifier, which is used in conjunction with |content_id|
     * to determine the set of keys to be returned in the license. Cannot be
     * present in conjunction with |key_ids|.
     * Current values are "commentary".
     *
     * @generated from field: optional string audio_feature = 16;
     */
    audioFeature: string

    /**
     * Entitlement period index for media using entitlement key rotation. Can only
     * present in ENTITLEMENT PSSHs. It always corresponds to the entitlement key
     * period.
     *
     * @generated from field: optional uint32 entitlement_period_index = 17;
     */
    entitlementPeriodIndex: number

    /**
     * @generated from field: optional video_widevine.WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];
     * @deprecated
     */
    algorithm: WidevinePsshData_Algorithm

    /**
     * @generated from field: optional string provider = 3 [deprecated = true];
     * @deprecated
     */
    provider: string

    /**
     * @generated from field: optional string track_type = 5 [deprecated = true];
     * @deprecated
     */
    trackType: string

    /**
     * @generated from field: optional string policy = 6 [deprecated = true];
     * @deprecated
     */
    policy: string

    /**
     * @generated from field: optional bytes grouped_license = 8 [deprecated = true];
     * @deprecated
     */
    groupedLicense: Uint8Array
}

/**
 * Describes the message video_widevine.WidevinePsshData.
 * Use `create(WidevinePsshDataSchema)` to create a new message.
 */
export const WidevinePsshDataSchema: GenMessage<WidevinePsshData> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 24)

/**
 * @generated from message video_widevine.WidevinePsshData.EntitledKey
 */
export type WidevinePsshData_EntitledKey =
    Message<'video_widevine.WidevinePsshData.EntitledKey'> & {
        /**
         * ID of entitlement key used for wrapping |key|.
         *
         * @generated from field: optional bytes entitlement_key_id = 1;
         */
        entitlementKeyId: Uint8Array

        /**
         * ID of the entitled key.
         *
         * @generated from field: optional bytes key_id = 2;
         */
        keyId: Uint8Array

        /**
         * Wrapped key. Required.
         *
         * @generated from field: optional bytes key = 3;
         */
        key: Uint8Array

        /**
         * IV used for wrapping |key|. Required.
         *
         * @generated from field: optional bytes iv = 4;
         */
        iv: Uint8Array

        /**
         * Size of entitlement key used for wrapping |key|.
         *
         * @generated from field: optional uint32 entitlement_key_size_bytes = 5 [default = 32];
         */
        entitlementKeySizeBytes: number
    }

/**
 * Describes the message video_widevine.WidevinePsshData.EntitledKey.
 * Use `create(WidevinePsshData_EntitledKeySchema)` to create a new message.
 */
export const WidevinePsshData_EntitledKeySchema: GenMessage<WidevinePsshData_EntitledKey> =
    /*@__PURE__*/
    messageDesc(file_license_protocol, 24, 0)

/**
 * @generated from enum video_widevine.WidevinePsshData.Type
 */
export enum WidevinePsshData_Type {
    /**
     * Single PSSH to be used to retrieve content keys.
     *
     * @generated from enum value: SINGLE = 0;
     */
    SINGLE = 0,

    /**
     * Primary PSSH used to retrieve entitlement keys.
     *
     * @generated from enum value: ENTITLEMENT = 1;
     */
    ENTITLEMENT = 1,

    /**
     * Secondary PSSH containing entitled key(s).
     *
     * @generated from enum value: ENTITLED_KEY = 2;
     */
    ENTITLED_KEY = 2
}

/**
 * Describes the enum video_widevine.WidevinePsshData.Type.
 */
export const WidevinePsshData_TypeSchema: GenEnum<WidevinePsshData_Type> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 24, 0)

/**
 * //////////////////////////  Deprecated Fields  ////////////////////////////
 *
 * @generated from enum video_widevine.WidevinePsshData.Algorithm
 */
export enum WidevinePsshData_Algorithm {
    /**
     * @generated from enum value: UNENCRYPTED = 0;
     */
    UNENCRYPTED = 0,

    /**
     * @generated from enum value: AESCTR = 1;
     */
    AESCTR = 1
}

/**
 * Describes the enum video_widevine.WidevinePsshData.Algorithm.
 */
export const WidevinePsshData_AlgorithmSchema: GenEnum<WidevinePsshData_Algorithm> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 24, 1)

/**
 * @generated from enum video_widevine.LicenseType
 */
export enum LicenseType {
    /**
     * @generated from enum value: STREAMING = 1;
     */
    STREAMING = 1,

    /**
     * @generated from enum value: OFFLINE = 2;
     */
    OFFLINE = 2,

    /**
     * License type decision is left to provider.
     *
     * @generated from enum value: AUTOMATIC = 3;
     */
    AUTOMATIC = 3
}

/**
 * Describes the enum video_widevine.LicenseType.
 */
export const LicenseTypeSchema: GenEnum<LicenseType> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 0)

/**
 * @generated from enum video_widevine.PlatformVerificationStatus
 */
export enum PlatformVerificationStatus {
    /**
     * The platform is not verified.
     *
     * @generated from enum value: PLATFORM_UNVERIFIED = 0;
     */
    PLATFORM_UNVERIFIED = 0,

    /**
     * Tampering detected on the platform.
     *
     * @generated from enum value: PLATFORM_TAMPERED = 1;
     */
    PLATFORM_TAMPERED = 1,

    /**
     * The platform has been verified by means of software.
     *
     * @generated from enum value: PLATFORM_SOFTWARE_VERIFIED = 2;
     */
    PLATFORM_SOFTWARE_VERIFIED = 2,

    /**
     * The platform has been verified by means of hardware (e.g. secure boot).
     *
     * @generated from enum value: PLATFORM_HARDWARE_VERIFIED = 3;
     */
    PLATFORM_HARDWARE_VERIFIED = 3,

    /**
     * Platform verification was not performed.
     *
     * @generated from enum value: PLATFORM_NO_VERIFICATION = 4;
     */
    PLATFORM_NO_VERIFICATION = 4,

    /**
     * Platform and secure storage capability have been verified by means of
     * software.
     *
     * @generated from enum value: PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5;
     */
    PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5
}

/**
 * Describes the enum video_widevine.PlatformVerificationStatus.
 */
export const PlatformVerificationStatusSchema: GenEnum<PlatformVerificationStatus> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 1)

/**
 * @generated from enum video_widevine.ProtocolVersion
 */
export enum ProtocolVersion {
    /**
     * @generated from enum value: VERSION_2_0 = 20;
     */
    VERSION_2_0 = 20,

    /**
     * @generated from enum value: VERSION_2_1 = 21;
     */
    VERSION_2_1 = 21,

    /**
     * @generated from enum value: VERSION_2_2 = 22;
     */
    VERSION_2_2 = 22
}

/**
 * Describes the enum video_widevine.ProtocolVersion.
 */
export const ProtocolVersionSchema: GenEnum<ProtocolVersion> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 2)

/**
 * @generated from enum video_widevine.HashAlgorithmProto
 */
export enum HashAlgorithmProto {
    /**
     * Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
     * and SHA_1 shall be used otherwise.
     *
     * @generated from enum value: HASH_ALGORITHM_UNSPECIFIED = 0;
     */
    HASH_ALGORITHM_UNSPECIFIED = 0,

    /**
     * @generated from enum value: HASH_ALGORITHM_SHA_1 = 1;
     */
    HASH_ALGORITHM_SHA_1 = 1,

    /**
     * @generated from enum value: HASH_ALGORITHM_SHA_256 = 2;
     */
    HASH_ALGORITHM_SHA_256 = 2,

    /**
     * @generated from enum value: HASH_ALGORITHM_SHA_384 = 3;
     */
    HASH_ALGORITHM_SHA_384 = 3
}

/**
 * Describes the enum video_widevine.HashAlgorithmProto.
 */
export const HashAlgorithmProtoSchema: GenEnum<HashAlgorithmProto> =
    /*@__PURE__*/
    enumDesc(file_license_protocol, 3)
