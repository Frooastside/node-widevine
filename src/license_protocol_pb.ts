// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file license_protocol.proto (package license_protocol, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum license_protocol.LicenseType
 */
export enum LicenseType {
  /**
   * @generated from enum value: STREAMING = 1;
   */
  STREAMING = 1,

  /**
   * @generated from enum value: OFFLINE = 2;
   */
  OFFLINE = 2,

  /**
   * License type decision is left to provider.
   *
   * @generated from enum value: AUTOMATIC = 3;
   */
  AUTOMATIC = 3
}
// Retrieve enum metadata with: proto2.getEnumType(LicenseType)
proto2.util.setEnumType(LicenseType, "license_protocol.LicenseType", [
  { no: 1, name: "STREAMING" },
  { no: 2, name: "OFFLINE" },
  { no: 3, name: "AUTOMATIC" }
]);

/**
 * @generated from enum license_protocol.PlatformVerificationStatus
 */
export enum PlatformVerificationStatus {
  /**
   * The platform is not verified.
   *
   * @generated from enum value: PLATFORM_UNVERIFIED = 0;
   */
  PLATFORM_UNVERIFIED = 0,

  /**
   * Tampering detected on the platform.
   *
   * @generated from enum value: PLATFORM_TAMPERED = 1;
   */
  PLATFORM_TAMPERED = 1,

  /**
   * The platform has been verified by means of software.
   *
   * @generated from enum value: PLATFORM_SOFTWARE_VERIFIED = 2;
   */
  PLATFORM_SOFTWARE_VERIFIED = 2,

  /**
   * The platform has been verified by means of hardware (e.g. secure boot).
   *
   * @generated from enum value: PLATFORM_HARDWARE_VERIFIED = 3;
   */
  PLATFORM_HARDWARE_VERIFIED = 3,

  /**
   * Platform verification was not performed.
   *
   * @generated from enum value: PLATFORM_NO_VERIFICATION = 4;
   */
  PLATFORM_NO_VERIFICATION = 4,

  /**
   * Platform and secure storage capability have been verified by means of
   * software.
   *
   * @generated from enum value: PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5;
   */
  PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5
}
// Retrieve enum metadata with: proto2.getEnumType(PlatformVerificationStatus)
proto2.util.setEnumType(PlatformVerificationStatus, "license_protocol.PlatformVerificationStatus", [
  { no: 0, name: "PLATFORM_UNVERIFIED" },
  { no: 1, name: "PLATFORM_TAMPERED" },
  { no: 2, name: "PLATFORM_SOFTWARE_VERIFIED" },
  { no: 3, name: "PLATFORM_HARDWARE_VERIFIED" },
  { no: 4, name: "PLATFORM_NO_VERIFICATION" },
  { no: 5, name: "PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED" }
]);

/**
 * @generated from enum license_protocol.ProtocolVersion
 */
export enum ProtocolVersion {
  /**
   * @generated from enum value: VERSION_2_0 = 20;
   */
  VERSION_2_0 = 20,

  /**
   * @generated from enum value: VERSION_2_1 = 21;
   */
  VERSION_2_1 = 21,

  /**
   * @generated from enum value: VERSION_2_2 = 22;
   */
  VERSION_2_2 = 22
}
// Retrieve enum metadata with: proto2.getEnumType(ProtocolVersion)
proto2.util.setEnumType(ProtocolVersion, "license_protocol.ProtocolVersion", [
  { no: 20, name: "VERSION_2_0" },
  { no: 21, name: "VERSION_2_1" },
  { no: 22, name: "VERSION_2_2" }
]);

/**
 * @generated from enum license_protocol.HashAlgorithmProto
 */
export enum HashAlgorithmProto {
  /**
   * Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
   * and SHA_1 shall be used otherwise.
   *
   * @generated from enum value: HASH_ALGORITHM_UNSPECIFIED = 0;
   */
  HASH_ALGORITHM_UNSPECIFIED = 0,

  /**
   * @generated from enum value: HASH_ALGORITHM_SHA_1 = 1;
   */
  HASH_ALGORITHM_SHA_1 = 1,

  /**
   * @generated from enum value: HASH_ALGORITHM_SHA_256 = 2;
   */
  HASH_ALGORITHM_SHA_256 = 2,

  /**
   * @generated from enum value: HASH_ALGORITHM_SHA_384 = 3;
   */
  HASH_ALGORITHM_SHA_384 = 3
}
// Retrieve enum metadata with: proto2.getEnumType(HashAlgorithmProto)
proto2.util.setEnumType(HashAlgorithmProto, "license_protocol.HashAlgorithmProto", [
  { no: 0, name: "HASH_ALGORITHM_UNSPECIFIED" },
  { no: 1, name: "HASH_ALGORITHM_SHA_1" },
  { no: 2, name: "HASH_ALGORITHM_SHA_256" },
  { no: 3, name: "HASH_ALGORITHM_SHA_384" }
]);

/**
 * LicenseIdentification is propagated from LicenseRequest to License,
 * incrementing version with each iteration.
 *
 * @generated from message license_protocol.LicenseIdentification
 */
export class LicenseIdentification extends Message<LicenseIdentification> {
  /**
   * @generated from field: optional bytes request_id = 1;
   */
  requestId?: Uint8Array;

  /**
   * @generated from field: optional bytes session_id = 2;
   */
  sessionId?: Uint8Array;

  /**
   * @generated from field: optional bytes purchase_id = 3;
   */
  purchaseId?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.LicenseType type = 4;
   */
  type?: LicenseType;

  /**
   * @generated from field: optional int32 version = 5;
   */
  version?: number;

  /**
   * @generated from field: optional bytes provider_session_token = 6;
   */
  providerSessionToken?: Uint8Array;

  constructor(data?: PartialMessage<LicenseIdentification>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.LicenseIdentification";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "request_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "session_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "purchase_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "type", kind: "enum", T: proto2.getEnumType(LicenseType), opt: true },
    { no: 5, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "provider_session_token", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseIdentification {
    return new LicenseIdentification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseIdentification {
    return new LicenseIdentification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseIdentification {
    return new LicenseIdentification().fromJsonString(jsonString, options);
  }

  static equals(
    a: LicenseIdentification | PlainMessage<LicenseIdentification> | undefined,
    b: LicenseIdentification | PlainMessage<LicenseIdentification> | undefined
  ): boolean {
    return proto2.util.equals(LicenseIdentification, a, b);
  }
}

/**
 * @generated from message license_protocol.License
 */
export class License extends Message<License> {
  /**
   * @generated from field: optional license_protocol.LicenseIdentification id = 1;
   */
  id?: LicenseIdentification;

  /**
   * @generated from field: optional license_protocol.License.Policy policy = 2;
   */
  policy?: License_Policy;

  /**
   * @generated from field: repeated license_protocol.License.KeyContainer key = 3;
   */
  key: License_KeyContainer[] = [];

  /**
   * Time of the request in seconds (UTC) as set in
   * LicenseRequest.request_time.  If this time is not set in the request,
   * the local time at the license service is used in this field.
   *
   * @generated from field: optional int64 license_start_time = 4;
   */
  licenseStartTime?: bigint;

  /**
   * @generated from field: optional bool remote_attestation_verified = 5 [default = false];
   */
  remoteAttestationVerified?: boolean;

  /**
   * Client token generated by the content provider. Optional.
   *
   * @generated from field: optional bytes provider_client_token = 6;
   */
  providerClientToken?: Uint8Array;

  /**
   * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
   * specification. Propagated from Widevine PSSH box. Optional.
   *
   * @generated from field: optional uint32 protection_scheme = 7;
   */
  protectionScheme?: number;

  /**
   * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
   * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
   * depends on client max_hdcp_version).
   * Additional details can be found in Widevine Modular DRM Security
   * Integration Guide for CENC.
   *
   * @generated from field: optional bytes srm_requirement = 8;
   */
  srmRequirement?: Uint8Array;

  /**
   * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
   * depending on client max_hdcp_version) that should be installed on the
   * client device.
   *
   * @generated from field: optional bytes srm_update = 9;
   */
  srmUpdate?: Uint8Array;

  /**
   * Indicates the status of any type of platform verification performed by the
   * server.
   *
   * @generated from field: optional license_protocol.PlatformVerificationStatus platform_verification_status = 10 [default = PLATFORM_NO_VERIFICATION];
   */
  platformVerificationStatus?: PlatformVerificationStatus;

  /**
   * IDs of the groups for which keys are delivered in this license, if any.
   *
   * @generated from field: repeated bytes group_ids = 11;
   */
  groupIds: Uint8Array[] = [];

  constructor(data?: PartialMessage<License>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.License";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: LicenseIdentification, opt: true },
    { no: 2, name: "policy", kind: "message", T: License_Policy, opt: true },
    { no: 3, name: "key", kind: "message", T: License_KeyContainer, repeated: true },
    { no: 4, name: "license_start_time", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 5, name: "remote_attestation_verified", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 6, name: "provider_client_token", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 7, name: "protection_scheme", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 8, name: "srm_requirement", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 9, name: "srm_update", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    {
      no: 10,
      name: "platform_verification_status",
      kind: "enum",
      T: proto2.getEnumType(PlatformVerificationStatus),
      opt: true,
      default: PlatformVerificationStatus.PLATFORM_NO_VERIFICATION
    },
    { no: 11, name: "group_ids", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License {
    return new License().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License {
    return new License().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License {
    return new License().fromJsonString(jsonString, options);
  }

  static equals(a: License | PlainMessage<License> | undefined, b: License | PlainMessage<License> | undefined): boolean {
    return proto2.util.equals(License, a, b);
  }
}

/**
 * @generated from message license_protocol.License.Policy
 */
export class License_Policy extends Message<License_Policy> {
  /**
   * Indicates that playback of the content is allowed.
   *
   * @generated from field: optional bool can_play = 1 [default = false];
   */
  canPlay?: boolean;

  /**
   * Indicates that the license may be persisted to non-volatile
   * storage for offline use.
   *
   * @generated from field: optional bool can_persist = 2 [default = false];
   */
  canPersist?: boolean;

  /**
   * Indicates that renewal of this license is allowed.
   *
   * @generated from field: optional bool can_renew = 3 [default = false];
   */
  canRenew?: boolean;

  /**
   * Indicates the rental window.
   *
   * @generated from field: optional int64 rental_duration_seconds = 4 [default = 0];
   */
  rentalDurationSeconds?: bigint;

  /**
   * Indicates the viewing window, once playback has begun.
   *
   * @generated from field: optional int64 playback_duration_seconds = 5 [default = 0];
   */
  playbackDurationSeconds?: bigint;

  /**
   * Indicates the time window for this specific license.
   *
   * @generated from field: optional int64 license_duration_seconds = 6 [default = 0];
   */
  licenseDurationSeconds?: bigint;

  /**
   * The window of time, in which playback is allowed to continue while
   * renewal is attempted, yet unsuccessful due to backend problems with
   * the license server.
   *
   * @generated from field: optional int64 renewal_recovery_duration_seconds = 7 [default = 0];
   */
  renewalRecoveryDurationSeconds?: bigint;

  /**
   * All renewal requests for this license shall be directed to the
   * specified URL.
   *
   * @generated from field: optional string renewal_server_url = 8;
   */
  renewalServerUrl?: string;

  /**
   * How many seconds after license_start_time, before renewal is first
   * attempted.
   *
   * @generated from field: optional int64 renewal_delay_seconds = 9 [default = 0];
   */
  renewalDelaySeconds?: bigint;

  /**
   * Specifies the delay in seconds between subsequent license
   * renewal requests, in case of failure.
   *
   * @generated from field: optional int64 renewal_retry_interval_seconds = 10 [default = 0];
   */
  renewalRetryIntervalSeconds?: bigint;

  /**
   * Indicates that the license shall be sent for renewal when usage is
   * started.
   *
   * @generated from field: optional bool renew_with_usage = 11 [default = false];
   */
  renewWithUsage?: boolean;

  /**
   * Indicates to client that license renewal and release requests ought to
   * include ClientIdentification (client_id).
   *
   * @generated from field: optional bool always_include_client_id = 12 [default = false];
   */
  alwaysIncludeClientId?: boolean;

  /**
   * Duration of grace period before playback_duration_seconds (short window)
   * goes into effect. Optional.
   *
   * @generated from field: optional int64 play_start_grace_period_seconds = 13 [default = 0];
   */
  playStartGracePeriodSeconds?: bigint;

  /**
   * Enables "soft enforcement" of playback_duration_seconds, letting the user
   * finish playback even if short window expires. Optional.
   *
   * @generated from field: optional bool soft_enforce_playback_duration = 14 [default = false];
   */
  softEnforcePlaybackDuration?: boolean;

  /**
   * Enables "soft enforcement" of rental_duration_seconds. Initial playback
   * must always start before rental duration expires.  In order to allow
   * subsequent playbacks to start after the rental duration expires,
   * soft_enforce_playback_duration must be true. Otherwise, subsequent
   * playbacks will not be allowed once rental duration expires. Optional.
   *
   * @generated from field: optional bool soft_enforce_rental_duration = 15 [default = true];
   */
  softEnforceRentalDuration?: boolean;

  constructor(data?: PartialMessage<License_Policy>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.License.Policy";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "can_play", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 2, name: "can_persist", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 3, name: "can_renew", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 4, name: "rental_duration_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero },
    { no: 5, name: "playback_duration_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero },
    { no: 6, name: "license_duration_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero },
    { no: 7, name: "renewal_recovery_duration_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero },
    { no: 8, name: "renewal_server_url", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "renewal_delay_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero },
    { no: 10, name: "renewal_retry_interval_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero },
    { no: 11, name: "renew_with_usage", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 12, name: "always_include_client_id", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 13, name: "play_start_grace_period_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero },
    { no: 14, name: "soft_enforce_playback_duration", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 15, name: "soft_enforce_rental_duration", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License_Policy {
    return new License_Policy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License_Policy {
    return new License_Policy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License_Policy {
    return new License_Policy().fromJsonString(jsonString, options);
  }

  static equals(a: License_Policy | PlainMessage<License_Policy> | undefined, b: License_Policy | PlainMessage<License_Policy> | undefined): boolean {
    return proto2.util.equals(License_Policy, a, b);
  }
}

/**
 * @generated from message license_protocol.License.KeyContainer
 */
export class License_KeyContainer extends Message<License_KeyContainer> {
  /**
   * @generated from field: optional bytes id = 1;
   */
  id?: Uint8Array;

  /**
   * @generated from field: optional bytes iv = 2;
   */
  iv?: Uint8Array;

  /**
   * @generated from field: optional bytes key = 3;
   */
  key?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.KeyType type = 4;
   */
  type?: License_KeyContainer_KeyType;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.SecurityLevel level = 5 [default = SW_SECURE_CRYPTO];
   */
  level?: License_KeyContainer_SecurityLevel;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection required_protection = 6;
   */
  requiredProtection?: License_KeyContainer_OutputProtection;

  /**
   * NOTE: Use of requested_protection is not recommended as it is only
   * supported on a small number of platforms.
   *
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection requested_protection = 7;
   */
  requestedProtection?: License_KeyContainer_OutputProtection;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.KeyControl key_control = 8;
   */
  keyControl?: License_KeyContainer_KeyControl;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
   */
  operatorSessionKeyPermissions?: License_KeyContainer_OperatorSessionKeyPermissions;

  /**
   * Optional video resolution constraints. If the video resolution of the
   * content being decrypted/decoded falls within one of the specified ranges,
   * the optional required_protections may be applied. Otherwise an error will
   * be reported.
   * NOTE: Use of this feature is not recommended, as it is only supported on
   * a small number of platforms.
   *
   * @generated from field: repeated license_protocol.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
   */
  videoResolutionConstraints: License_KeyContainer_VideoResolutionConstraint[] = [];

  /**
   * Optional flag to indicate the key must only be used if the client
   * supports anti rollback of the user table.  Content provider can query the
   * client capabilities to determine if the client support this feature.
   *
   * @generated from field: optional bool anti_rollback_usage_table = 11 [default = false];
   */
  antiRollbackUsageTable?: boolean;

  /**
   * Optional not limited to commonly known track types such as SD, HD.
   * It can be some provider defined label to identify the track.
   *
   * @generated from field: optional string track_label = 12;
   */
  trackLabel?: string;

  constructor(data?: PartialMessage<License_KeyContainer>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.License.KeyContainer";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "iv", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "type", kind: "enum", T: proto2.getEnumType(License_KeyContainer_KeyType), opt: true },
    {
      no: 5,
      name: "level",
      kind: "enum",
      T: proto2.getEnumType(License_KeyContainer_SecurityLevel),
      opt: true,
      default: License_KeyContainer_SecurityLevel.SW_SECURE_CRYPTO
    },
    { no: 6, name: "required_protection", kind: "message", T: License_KeyContainer_OutputProtection, opt: true },
    { no: 7, name: "requested_protection", kind: "message", T: License_KeyContainer_OutputProtection, opt: true },
    { no: 8, name: "key_control", kind: "message", T: License_KeyContainer_KeyControl, opt: true },
    { no: 9, name: "operator_session_key_permissions", kind: "message", T: License_KeyContainer_OperatorSessionKeyPermissions, opt: true },
    { no: 10, name: "video_resolution_constraints", kind: "message", T: License_KeyContainer_VideoResolutionConstraint, repeated: true },
    { no: 11, name: "anti_rollback_usage_table", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 12, name: "track_label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License_KeyContainer {
    return new License_KeyContainer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License_KeyContainer {
    return new License_KeyContainer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License_KeyContainer {
    return new License_KeyContainer().fromJsonString(jsonString, options);
  }

  static equals(
    a: License_KeyContainer | PlainMessage<License_KeyContainer> | undefined,
    b: License_KeyContainer | PlainMessage<License_KeyContainer> | undefined
  ): boolean {
    return proto2.util.equals(License_KeyContainer, a, b);
  }
}

/**
 * @generated from enum license_protocol.License.KeyContainer.KeyType
 */
export enum License_KeyContainer_KeyType {
  /**
   * Exactly one key of this type must appear.
   *
   * @generated from enum value: SIGNING = 1;
   */
  SIGNING = 1,

  /**
   * Content key.
   *
   * @generated from enum value: CONTENT = 2;
   */
  CONTENT = 2,

  /**
   * Key control block for license renewals. No key.
   *
   * @generated from enum value: KEY_CONTROL = 3;
   */
  KEY_CONTROL = 3,

  /**
   * wrapped keys for auxiliary crypto operations.
   *
   * @generated from enum value: OPERATOR_SESSION = 4;
   */
  OPERATOR_SESSION = 4,

  /**
   * Entitlement keys.
   *
   * @generated from enum value: ENTITLEMENT = 5;
   */
  ENTITLEMENT = 5,

  /**
   * Partner-specific content key.
   *
   * @generated from enum value: OEM_CONTENT = 6;
   */
  OEM_CONTENT = 6
}
// Retrieve enum metadata with: proto2.getEnumType(License_KeyContainer_KeyType)
proto2.util.setEnumType(License_KeyContainer_KeyType, "license_protocol.License.KeyContainer.KeyType", [
  { no: 1, name: "SIGNING" },
  { no: 2, name: "CONTENT" },
  { no: 3, name: "KEY_CONTROL" },
  { no: 4, name: "OPERATOR_SESSION" },
  { no: 5, name: "ENTITLEMENT" },
  { no: 6, name: "OEM_CONTENT" }
]);

/**
 * The SecurityLevel enumeration allows the server to communicate the level
 * of robustness required by the client, in order to use the key.
 *
 * @generated from enum license_protocol.License.KeyContainer.SecurityLevel
 */
export enum License_KeyContainer_SecurityLevel {
  /**
   * Software-based whitebox crypto is required.
   *
   * @generated from enum value: SW_SECURE_CRYPTO = 1;
   */
  SW_SECURE_CRYPTO = 1,

  /**
   * Software crypto and an obfuscated decoder is required.
   *
   * @generated from enum value: SW_SECURE_DECODE = 2;
   */
  SW_SECURE_DECODE = 2,

  /**
   * The key material and crypto operations must be performed within a
   * hardware backed trusted execution environment.
   *
   * @generated from enum value: HW_SECURE_CRYPTO = 3;
   */
  HW_SECURE_CRYPTO = 3,

  /**
   * The crypto and decoding of content must be performed within a hardware
   * backed trusted execution environment.
   *
   * @generated from enum value: HW_SECURE_DECODE = 4;
   */
  HW_SECURE_DECODE = 4,

  /**
   * The crypto, decoding and all handling of the media (compressed and
   * uncompressed) must be handled within a hardware backed trusted
   * execution environment.
   *
   * @generated from enum value: HW_SECURE_ALL = 5;
   */
  HW_SECURE_ALL = 5
}
// Retrieve enum metadata with: proto2.getEnumType(License_KeyContainer_SecurityLevel)
proto2.util.setEnumType(License_KeyContainer_SecurityLevel, "license_protocol.License.KeyContainer.SecurityLevel", [
  { no: 1, name: "SW_SECURE_CRYPTO" },
  { no: 2, name: "SW_SECURE_DECODE" },
  { no: 3, name: "HW_SECURE_CRYPTO" },
  { no: 4, name: "HW_SECURE_DECODE" },
  { no: 5, name: "HW_SECURE_ALL" }
]);

/**
 * @generated from message license_protocol.License.KeyContainer.KeyControl
 */
export class License_KeyContainer_KeyControl extends Message<License_KeyContainer_KeyControl> {
  /**
   * |key_control| is documented in:
   * Widevine Modular DRM Security Integration Guide for CENC
   * If present, the key control must be communicated to the secure
   * environment prior to any usage. This message is automatically generated
   * by the Widevine License Server SDK.
   *
   * @generated from field: optional bytes key_control_block = 1;
   */
  keyControlBlock?: Uint8Array;

  /**
   * @generated from field: optional bytes iv = 2;
   */
  iv?: Uint8Array;

  constructor(data?: PartialMessage<License_KeyContainer_KeyControl>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.License.KeyContainer.KeyControl";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "key_control_block", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "iv", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License_KeyContainer_KeyControl {
    return new License_KeyContainer_KeyControl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License_KeyContainer_KeyControl {
    return new License_KeyContainer_KeyControl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License_KeyContainer_KeyControl {
    return new License_KeyContainer_KeyControl().fromJsonString(jsonString, options);
  }

  static equals(
    a: License_KeyContainer_KeyControl | PlainMessage<License_KeyContainer_KeyControl> | undefined,
    b: License_KeyContainer_KeyControl | PlainMessage<License_KeyContainer_KeyControl> | undefined
  ): boolean {
    return proto2.util.equals(License_KeyContainer_KeyControl, a, b);
  }
}

/**
 * @generated from message license_protocol.License.KeyContainer.OutputProtection
 */
export class License_KeyContainer_OutputProtection extends Message<License_KeyContainer_OutputProtection> {
  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.HDCP hdcp = 1 [default = HDCP_NONE];
   */
  hdcp?: License_KeyContainer_OutputProtection_HDCP;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2 [default = CGMS_NONE];
   */
  cgmsFlags?: License_KeyContainer_OutputProtection_CGMS;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3 [default = HDCP_SRM_RULE_NONE];
   */
  hdcpSrmRule?: License_KeyContainer_OutputProtection_HdcpSrmRule;

  /**
   * Optional requirement to indicate analog output is not allowed.
   *
   * @generated from field: optional bool disable_analog_output = 4 [default = false];
   */
  disableAnalogOutput?: boolean;

  /**
   * Optional requirement to indicate digital output is not allowed.
   *
   * @generated from field: optional bool disable_digital_output = 5 [default = false];
   */
  disableDigitalOutput?: boolean;

  constructor(data?: PartialMessage<License_KeyContainer_OutputProtection>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.License.KeyContainer.OutputProtection";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    {
      no: 1,
      name: "hdcp",
      kind: "enum",
      T: proto2.getEnumType(License_KeyContainer_OutputProtection_HDCP),
      opt: true,
      default: License_KeyContainer_OutputProtection_HDCP.HDCP_NONE
    },
    {
      no: 2,
      name: "cgms_flags",
      kind: "enum",
      T: proto2.getEnumType(License_KeyContainer_OutputProtection_CGMS),
      opt: true,
      default: License_KeyContainer_OutputProtection_CGMS.CGMS_NONE
    },
    {
      no: 3,
      name: "hdcp_srm_rule",
      kind: "enum",
      T: proto2.getEnumType(License_KeyContainer_OutputProtection_HdcpSrmRule),
      opt: true,
      default: License_KeyContainer_OutputProtection_HdcpSrmRule.HDCP_SRM_RULE_NONE
    },
    { no: 4, name: "disable_analog_output", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 5, name: "disable_digital_output", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License_KeyContainer_OutputProtection {
    return new License_KeyContainer_OutputProtection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License_KeyContainer_OutputProtection {
    return new License_KeyContainer_OutputProtection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License_KeyContainer_OutputProtection {
    return new License_KeyContainer_OutputProtection().fromJsonString(jsonString, options);
  }

  static equals(
    a: License_KeyContainer_OutputProtection | PlainMessage<License_KeyContainer_OutputProtection> | undefined,
    b: License_KeyContainer_OutputProtection | PlainMessage<License_KeyContainer_OutputProtection> | undefined
  ): boolean {
    return proto2.util.equals(License_KeyContainer_OutputProtection, a, b);
  }
}

/**
 * Indicates whether HDCP is required on digital outputs, and which
 * version should be used.
 *
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.HDCP
 */
export enum License_KeyContainer_OutputProtection_HDCP {
  /**
   * @generated from enum value: HDCP_NONE = 0;
   */
  HDCP_NONE = 0,

  /**
   * @generated from enum value: HDCP_V1 = 1;
   */
  HDCP_V1 = 1,

  /**
   * @generated from enum value: HDCP_V2 = 2;
   */
  HDCP_V2 = 2,

  /**
   * @generated from enum value: HDCP_V2_1 = 3;
   */
  HDCP_V2_1 = 3,

  /**
   * @generated from enum value: HDCP_V2_2 = 4;
   */
  HDCP_V2_2 = 4,

  /**
   * @generated from enum value: HDCP_V2_3 = 5;
   */
  HDCP_V2_3 = 5,

  /**
   * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
   */
  HDCP_NO_DIGITAL_OUTPUT = 255
}
// Retrieve enum metadata with: proto2.getEnumType(License_KeyContainer_OutputProtection_HDCP)
proto2.util.setEnumType(License_KeyContainer_OutputProtection_HDCP, "license_protocol.License.KeyContainer.OutputProtection.HDCP", [
  { no: 0, name: "HDCP_NONE" },
  { no: 1, name: "HDCP_V1" },
  { no: 2, name: "HDCP_V2" },
  { no: 3, name: "HDCP_V2_1" },
  { no: 4, name: "HDCP_V2_2" },
  { no: 5, name: "HDCP_V2_3" },
  { no: 255, name: "HDCP_NO_DIGITAL_OUTPUT" }
]);

/**
 * Indicate the CGMS setting to be inserted on analog output.
 *
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.CGMS
 */
export enum License_KeyContainer_OutputProtection_CGMS {
  /**
   * @generated from enum value: CGMS_NONE = 42;
   */
  CGMS_NONE = 42,

  /**
   * @generated from enum value: COPY_FREE = 0;
   */
  COPY_FREE = 0,

  /**
   * @generated from enum value: COPY_ONCE = 2;
   */
  COPY_ONCE = 2,

  /**
   * @generated from enum value: COPY_NEVER = 3;
   */
  COPY_NEVER = 3
}
// Retrieve enum metadata with: proto2.getEnumType(License_KeyContainer_OutputProtection_CGMS)
proto2.util.setEnumType(License_KeyContainer_OutputProtection_CGMS, "license_protocol.License.KeyContainer.OutputProtection.CGMS", [
  { no: 42, name: "CGMS_NONE" },
  { no: 0, name: "COPY_FREE" },
  { no: 2, name: "COPY_ONCE" },
  { no: 3, name: "COPY_NEVER" }
]);

/**
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule
 */
export enum License_KeyContainer_OutputProtection_HdcpSrmRule {
  /**
   * @generated from enum value: HDCP_SRM_RULE_NONE = 0;
   */
  HDCP_SRM_RULE_NONE = 0,

  /**
   * In 'required_protection', this means most current SRM is required.
   * Update the SRM on the device. If update cannot happen,
   * do not allow the key.
   * In 'requested_protection', this means most current SRM is requested.
   * Update the SRM on the device. If update cannot happen,
   * allow use of the key anyway.
   *
   * @generated from enum value: CURRENT_SRM = 1;
   */
  CURRENT_SRM = 1
}
// Retrieve enum metadata with: proto2.getEnumType(License_KeyContainer_OutputProtection_HdcpSrmRule)
proto2.util.setEnumType(License_KeyContainer_OutputProtection_HdcpSrmRule, "license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule", [
  { no: 0, name: "HDCP_SRM_RULE_NONE" },
  { no: 1, name: "CURRENT_SRM" }
]);

/**
 * @generated from message license_protocol.License.KeyContainer.VideoResolutionConstraint
 */
export class License_KeyContainer_VideoResolutionConstraint extends Message<License_KeyContainer_VideoResolutionConstraint> {
  /**
   * Minimum and maximum video resolutions in the range (height x width).
   *
   * @generated from field: optional uint32 min_resolution_pixels = 1;
   */
  minResolutionPixels?: number;

  /**
   * @generated from field: optional uint32 max_resolution_pixels = 2;
   */
  maxResolutionPixels?: number;

  /**
   * Optional output protection requirements for this range. If not
   * specified, the OutputProtection in the KeyContainer applies.
   *
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection required_protection = 3;
   */
  requiredProtection?: License_KeyContainer_OutputProtection;

  constructor(data?: PartialMessage<License_KeyContainer_VideoResolutionConstraint>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.License.KeyContainer.VideoResolutionConstraint";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "min_resolution_pixels", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "max_resolution_pixels", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 3, name: "required_protection", kind: "message", T: License_KeyContainer_OutputProtection, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License_KeyContainer_VideoResolutionConstraint {
    return new License_KeyContainer_VideoResolutionConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License_KeyContainer_VideoResolutionConstraint {
    return new License_KeyContainer_VideoResolutionConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License_KeyContainer_VideoResolutionConstraint {
    return new License_KeyContainer_VideoResolutionConstraint().fromJsonString(jsonString, options);
  }

  static equals(
    a: License_KeyContainer_VideoResolutionConstraint | PlainMessage<License_KeyContainer_VideoResolutionConstraint> | undefined,
    b: License_KeyContainer_VideoResolutionConstraint | PlainMessage<License_KeyContainer_VideoResolutionConstraint> | undefined
  ): boolean {
    return proto2.util.equals(License_KeyContainer_VideoResolutionConstraint, a, b);
  }
}

/**
 * @generated from message license_protocol.License.KeyContainer.OperatorSessionKeyPermissions
 */
export class License_KeyContainer_OperatorSessionKeyPermissions extends Message<License_KeyContainer_OperatorSessionKeyPermissions> {
  /**
   * Permissions/key usage flags for operator service keys
   * (type = OPERATOR_SESSION).
   *
   * @generated from field: optional bool allow_encrypt = 1 [default = false];
   */
  allowEncrypt?: boolean;

  /**
   * @generated from field: optional bool allow_decrypt = 2 [default = false];
   */
  allowDecrypt?: boolean;

  /**
   * @generated from field: optional bool allow_sign = 3 [default = false];
   */
  allowSign?: boolean;

  /**
   * @generated from field: optional bool allow_signature_verify = 4 [default = false];
   */
  allowSignatureVerify?: boolean;

  constructor(data?: PartialMessage<License_KeyContainer_OperatorSessionKeyPermissions>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.License.KeyContainer.OperatorSessionKeyPermissions";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "allow_encrypt", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 2, name: "allow_decrypt", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 3, name: "allow_sign", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 4, name: "allow_signature_verify", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): License_KeyContainer_OperatorSessionKeyPermissions {
    return new License_KeyContainer_OperatorSessionKeyPermissions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): License_KeyContainer_OperatorSessionKeyPermissions {
    return new License_KeyContainer_OperatorSessionKeyPermissions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): License_KeyContainer_OperatorSessionKeyPermissions {
    return new License_KeyContainer_OperatorSessionKeyPermissions().fromJsonString(jsonString, options);
  }

  static equals(
    a: License_KeyContainer_OperatorSessionKeyPermissions | PlainMessage<License_KeyContainer_OperatorSessionKeyPermissions> | undefined,
    b: License_KeyContainer_OperatorSessionKeyPermissions | PlainMessage<License_KeyContainer_OperatorSessionKeyPermissions> | undefined
  ): boolean {
    return proto2.util.equals(License_KeyContainer_OperatorSessionKeyPermissions, a, b);
  }
}

/**
 * @generated from message license_protocol.LicenseRequest
 */
export class LicenseRequest extends Message<LicenseRequest> {
  /**
   * The client_id provides information authenticating the calling device.  It
   * contains the Widevine keybox token that was installed on the device at the
   * factory.  This field or encrypted_client_id below is required for a valid
   * license request, but both should never be present in the same request.
   *
   * @generated from field: optional license_protocol.ClientIdentification client_id = 1;
   */
  clientId?: ClientIdentification;

  /**
   * @generated from field: optional license_protocol.LicenseRequest.ContentIdentification content_id = 2;
   */
  contentId?: LicenseRequest_ContentIdentification;

  /**
   * @generated from field: optional license_protocol.LicenseRequest.RequestType type = 3;
   */
  type?: LicenseRequest_RequestType;

  /**
   * Time of the request in seconds (UTC) as set by the client.
   *
   * @generated from field: optional int64 request_time = 4;
   */
  requestTime?: bigint;

  /**
   * Old-style decimal-encoded string key control nonce.
   *
   * @generated from field: optional bytes key_control_nonce_deprecated = 5;
   */
  keyControlNonceDeprecated?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.ProtocolVersion protocol_version = 6 [default = VERSION_2_0];
   */
  protocolVersion?: ProtocolVersion;

  /**
   * New-style uint32 key control nonce, please use instead of
   * key_control_nonce_deprecated.
   *
   * @generated from field: optional uint32 key_control_nonce = 7;
   */
  keyControlNonce?: number;

  /**
   * Encrypted ClientIdentification message, used for privacy purposes.
   *
   * @generated from field: optional license_protocol.EncryptedClientIdentification encrypted_client_id = 8;
   */
  encryptedClientId?: EncryptedClientIdentification;

  constructor(data?: PartialMessage<LicenseRequest>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.LicenseRequest";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "client_id", kind: "message", T: ClientIdentification, opt: true },
    { no: 2, name: "content_id", kind: "message", T: LicenseRequest_ContentIdentification, opt: true },
    { no: 3, name: "type", kind: "enum", T: proto2.getEnumType(LicenseRequest_RequestType), opt: true },
    { no: 4, name: "request_time", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 5, name: "key_control_nonce_deprecated", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 6, name: "protocol_version", kind: "enum", T: proto2.getEnumType(ProtocolVersion), opt: true, default: ProtocolVersion.VERSION_2_0 },
    { no: 7, name: "key_control_nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 8, name: "encrypted_client_id", kind: "message", T: EncryptedClientIdentification, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseRequest {
    return new LicenseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseRequest {
    return new LicenseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseRequest {
    return new LicenseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LicenseRequest | PlainMessage<LicenseRequest> | undefined, b: LicenseRequest | PlainMessage<LicenseRequest> | undefined): boolean {
    return proto2.util.equals(LicenseRequest, a, b);
  }
}

/**
 * @generated from enum license_protocol.LicenseRequest.RequestType
 */
export enum LicenseRequest_RequestType {
  /**
   * @generated from enum value: NEW = 1;
   */
  NEW = 1,

  /**
   * @generated from enum value: RENEWAL = 2;
   */
  RENEWAL = 2,

  /**
   * @generated from enum value: RELEASE = 3;
   */
  RELEASE = 3
}
// Retrieve enum metadata with: proto2.getEnumType(LicenseRequest_RequestType)
proto2.util.setEnumType(LicenseRequest_RequestType, "license_protocol.LicenseRequest.RequestType", [
  { no: 1, name: "NEW" },
  { no: 2, name: "RENEWAL" },
  { no: 3, name: "RELEASE" }
]);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification
 */
export class LicenseRequest_ContentIdentification extends Message<LicenseRequest_ContentIdentification> {
  /**
   * @generated from oneof license_protocol.LicenseRequest.ContentIdentification.content_id_variant
   */
  contentIdVariant:
    | {
        /**
         * Exactly one of these must be present.
         *
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;
         */
        value: LicenseRequest_ContentIdentification_WidevinePsshData;
        case: "widevinePsshData";
      }
    | {
        /**
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;
         */
        value: LicenseRequest_ContentIdentification_WebmKeyId;
        case: "webmKeyId";
      }
    | {
        /**
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;
         */
        value: LicenseRequest_ContentIdentification_ExistingLicense;
        case: "existingLicense";
      }
    | {
        /**
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.InitData init_data = 4;
         */
        value: LicenseRequest_ContentIdentification_InitData;
        case: "initData";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LicenseRequest_ContentIdentification>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.LicenseRequest.ContentIdentification";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "widevine_pssh_data", kind: "message", T: LicenseRequest_ContentIdentification_WidevinePsshData, oneof: "content_id_variant" },
    { no: 2, name: "webm_key_id", kind: "message", T: LicenseRequest_ContentIdentification_WebmKeyId, oneof: "content_id_variant" },
    { no: 3, name: "existing_license", kind: "message", T: LicenseRequest_ContentIdentification_ExistingLicense, oneof: "content_id_variant" },
    { no: 4, name: "init_data", kind: "message", T: LicenseRequest_ContentIdentification_InitData, oneof: "content_id_variant" }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseRequest_ContentIdentification {
    return new LicenseRequest_ContentIdentification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification {
    return new LicenseRequest_ContentIdentification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification {
    return new LicenseRequest_ContentIdentification().fromJsonString(jsonString, options);
  }

  static equals(
    a: LicenseRequest_ContentIdentification | PlainMessage<LicenseRequest_ContentIdentification> | undefined,
    b: LicenseRequest_ContentIdentification | PlainMessage<LicenseRequest_ContentIdentification> | undefined
  ): boolean {
    return proto2.util.equals(LicenseRequest_ContentIdentification, a, b);
  }
}

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData
 */
export class LicenseRequest_ContentIdentification_WidevinePsshData extends Message<LicenseRequest_ContentIdentification_WidevinePsshData> {
  /**
   * @generated from field: repeated bytes pssh_data = 1;
   */
  psshData: Uint8Array[] = [];

  /**
   * @generated from field: optional license_protocol.LicenseType license_type = 2;
   */
  licenseType?: LicenseType;

  /**
   * Opaque, client-specified.
   *
   * @generated from field: optional bytes request_id = 3;
   */
  requestId?: Uint8Array;

  constructor(data?: PartialMessage<LicenseRequest_ContentIdentification_WidevinePsshData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "pssh_data", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 2, name: "license_type", kind: "enum", T: proto2.getEnumType(LicenseType), opt: true },
    { no: 3, name: "request_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseRequest_ContentIdentification_WidevinePsshData {
    return new LicenseRequest_ContentIdentification_WidevinePsshData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_WidevinePsshData {
    return new LicenseRequest_ContentIdentification_WidevinePsshData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_WidevinePsshData {
    return new LicenseRequest_ContentIdentification_WidevinePsshData().fromJsonString(jsonString, options);
  }

  static equals(
    a: LicenseRequest_ContentIdentification_WidevinePsshData | PlainMessage<LicenseRequest_ContentIdentification_WidevinePsshData> | undefined,
    b: LicenseRequest_ContentIdentification_WidevinePsshData | PlainMessage<LicenseRequest_ContentIdentification_WidevinePsshData> | undefined
  ): boolean {
    return proto2.util.equals(LicenseRequest_ContentIdentification_WidevinePsshData, a, b);
  }
}

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.WebmKeyId
 */
export class LicenseRequest_ContentIdentification_WebmKeyId extends Message<LicenseRequest_ContentIdentification_WebmKeyId> {
  /**
   * @generated from field: optional bytes header = 1;
   */
  header?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.LicenseType license_type = 2;
   */
  licenseType?: LicenseType;

  /**
   * Opaque, client-specified.
   *
   * @generated from field: optional bytes request_id = 3;
   */
  requestId?: Uint8Array;

  constructor(data?: PartialMessage<LicenseRequest_ContentIdentification_WebmKeyId>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.LicenseRequest.ContentIdentification.WebmKeyId";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "header", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "license_type", kind: "enum", T: proto2.getEnumType(LicenseType), opt: true },
    { no: 3, name: "request_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseRequest_ContentIdentification_WebmKeyId {
    return new LicenseRequest_ContentIdentification_WebmKeyId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_WebmKeyId {
    return new LicenseRequest_ContentIdentification_WebmKeyId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_WebmKeyId {
    return new LicenseRequest_ContentIdentification_WebmKeyId().fromJsonString(jsonString, options);
  }

  static equals(
    a: LicenseRequest_ContentIdentification_WebmKeyId | PlainMessage<LicenseRequest_ContentIdentification_WebmKeyId> | undefined,
    b: LicenseRequest_ContentIdentification_WebmKeyId | PlainMessage<LicenseRequest_ContentIdentification_WebmKeyId> | undefined
  ): boolean {
    return proto2.util.equals(LicenseRequest_ContentIdentification_WebmKeyId, a, b);
  }
}

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.ExistingLicense
 */
export class LicenseRequest_ContentIdentification_ExistingLicense extends Message<LicenseRequest_ContentIdentification_ExistingLicense> {
  /**
   * @generated from field: optional license_protocol.LicenseIdentification license_id = 1;
   */
  licenseId?: LicenseIdentification;

  /**
   * @generated from field: optional int64 seconds_since_started = 2;
   */
  secondsSinceStarted?: bigint;

  /**
   * @generated from field: optional int64 seconds_since_last_played = 3;
   */
  secondsSinceLastPlayed?: bigint;

  /**
   * @generated from field: optional bytes session_usage_table_entry = 4;
   */
  sessionUsageTableEntry?: Uint8Array;

  constructor(data?: PartialMessage<LicenseRequest_ContentIdentification_ExistingLicense>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.LicenseRequest.ContentIdentification.ExistingLicense";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "license_id", kind: "message", T: LicenseIdentification, opt: true },
    { no: 2, name: "seconds_since_started", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 3, name: "seconds_since_last_played", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: "session_usage_table_entry", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseRequest_ContentIdentification_ExistingLicense {
    return new LicenseRequest_ContentIdentification_ExistingLicense().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_ExistingLicense {
    return new LicenseRequest_ContentIdentification_ExistingLicense().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_ExistingLicense {
    return new LicenseRequest_ContentIdentification_ExistingLicense().fromJsonString(jsonString, options);
  }

  static equals(
    a: LicenseRequest_ContentIdentification_ExistingLicense | PlainMessage<LicenseRequest_ContentIdentification_ExistingLicense> | undefined,
    b: LicenseRequest_ContentIdentification_ExistingLicense | PlainMessage<LicenseRequest_ContentIdentification_ExistingLicense> | undefined
  ): boolean {
    return proto2.util.equals(LicenseRequest_ContentIdentification_ExistingLicense, a, b);
  }
}

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.InitData
 */
export class LicenseRequest_ContentIdentification_InitData extends Message<LicenseRequest_ContentIdentification_InitData> {
  /**
   * @generated from field: optional license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1 [default = CENC];
   */
  initDataType?: LicenseRequest_ContentIdentification_InitData_InitDataType;

  /**
   * @generated from field: optional bytes init_data = 2;
   */
  initData?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.LicenseType license_type = 3;
   */
  licenseType?: LicenseType;

  /**
   * @generated from field: optional bytes request_id = 4;
   */
  requestId?: Uint8Array;

  constructor(data?: PartialMessage<LicenseRequest_ContentIdentification_InitData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.LicenseRequest.ContentIdentification.InitData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    {
      no: 1,
      name: "init_data_type",
      kind: "enum",
      T: proto2.getEnumType(LicenseRequest_ContentIdentification_InitData_InitDataType),
      opt: true,
      default: LicenseRequest_ContentIdentification_InitData_InitDataType.CENC
    },
    { no: 2, name: "init_data", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "license_type", kind: "enum", T: proto2.getEnumType(LicenseType), opt: true },
    { no: 4, name: "request_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LicenseRequest_ContentIdentification_InitData {
    return new LicenseRequest_ContentIdentification_InitData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_InitData {
    return new LicenseRequest_ContentIdentification_InitData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LicenseRequest_ContentIdentification_InitData {
    return new LicenseRequest_ContentIdentification_InitData().fromJsonString(jsonString, options);
  }

  static equals(
    a: LicenseRequest_ContentIdentification_InitData | PlainMessage<LicenseRequest_ContentIdentification_InitData> | undefined,
    b: LicenseRequest_ContentIdentification_InitData | PlainMessage<LicenseRequest_ContentIdentification_InitData> | undefined
  ): boolean {
    return proto2.util.equals(LicenseRequest_ContentIdentification_InitData, a, b);
  }
}

/**
 * @generated from enum license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType
 */
export enum LicenseRequest_ContentIdentification_InitData_InitDataType {
  /**
   * @generated from enum value: CENC = 1;
   */
  CENC = 1,

  /**
   * @generated from enum value: WEBM = 2;
   */
  WEBM = 2
}
// Retrieve enum metadata with: proto2.getEnumType(LicenseRequest_ContentIdentification_InitData_InitDataType)
proto2.util.setEnumType(
  LicenseRequest_ContentIdentification_InitData_InitDataType,
  "license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType",
  [
    { no: 1, name: "CENC" },
    { no: 2, name: "WEBM" }
  ]
);

/**
 * @generated from message license_protocol.MetricData
 */
export class MetricData extends Message<MetricData> {
  /**
   * 'stage' that is currently processing the SignedMessage.  Required.
   *
   * @generated from field: optional string stage_name = 1;
   */
  stageName?: string;

  /**
   * metric and associated value.
   *
   * @generated from field: repeated license_protocol.MetricData.TypeValue metric_data = 2;
   */
  metricData: MetricData_TypeValue[] = [];

  constructor(data?: PartialMessage<MetricData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.MetricData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "stage_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "metric_data", kind: "message", T: MetricData_TypeValue, repeated: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricData {
    return new MetricData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricData {
    return new MetricData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricData {
    return new MetricData().fromJsonString(jsonString, options);
  }

  static equals(a: MetricData | PlainMessage<MetricData> | undefined, b: MetricData | PlainMessage<MetricData> | undefined): boolean {
    return proto2.util.equals(MetricData, a, b);
  }
}

/**
 * @generated from enum license_protocol.MetricData.MetricType
 */
export enum MetricData_MetricType {
  /**
   * The time spent in the 'stage', specified in microseconds.
   *
   * @generated from enum value: LATENCY = 1;
   */
  LATENCY = 1,

  /**
   * The UNIX epoch timestamp at which the 'stage' was first accessed in
   * microseconds.
   *
   * @generated from enum value: TIMESTAMP = 2;
   */
  TIMESTAMP = 2
}
// Retrieve enum metadata with: proto2.getEnumType(MetricData_MetricType)
proto2.util.setEnumType(MetricData_MetricType, "license_protocol.MetricData.MetricType", [
  { no: 1, name: "LATENCY" },
  { no: 2, name: "TIMESTAMP" }
]);

/**
 * @generated from message license_protocol.MetricData.TypeValue
 */
export class MetricData_TypeValue extends Message<MetricData_TypeValue> {
  /**
   * @generated from field: optional license_protocol.MetricData.MetricType type = 1;
   */
  type?: MetricData_MetricType;

  /**
   * The value associated with 'type'.  For example if type == LATENCY, the
   * value would be the time in microseconds spent in this 'stage'.
   *
   * @generated from field: optional int64 value = 2 [default = 0];
   */
  value?: bigint;

  constructor(data?: PartialMessage<MetricData_TypeValue>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.MetricData.TypeValue";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto2.getEnumType(MetricData_MetricType), opt: true },
    { no: 2, name: "value", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true, default: protoInt64.zero }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricData_TypeValue {
    return new MetricData_TypeValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricData_TypeValue {
    return new MetricData_TypeValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricData_TypeValue {
    return new MetricData_TypeValue().fromJsonString(jsonString, options);
  }

  static equals(
    a: MetricData_TypeValue | PlainMessage<MetricData_TypeValue> | undefined,
    b: MetricData_TypeValue | PlainMessage<MetricData_TypeValue> | undefined
  ): boolean {
    return proto2.util.equals(MetricData_TypeValue, a, b);
  }
}

/**
 * @generated from message license_protocol.VersionInfo
 */
export class VersionInfo extends Message<VersionInfo> {
  /**
   * License SDK version reported by the Widevine License SDK. This field
   * is populated automatically by the SDK.
   *
   * @generated from field: optional string license_sdk_version = 1;
   */
  licenseSdkVersion?: string;

  /**
   * Version of the service hosting the license SDK. This field is optional.
   * It may be provided by the hosting service.
   *
   * @generated from field: optional string license_service_version = 2;
   */
  licenseServiceVersion?: string;

  constructor(data?: PartialMessage<VersionInfo>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.VersionInfo";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "license_sdk_version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "license_service_version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VersionInfo {
    return new VersionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VersionInfo {
    return new VersionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VersionInfo {
    return new VersionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: VersionInfo | PlainMessage<VersionInfo> | undefined, b: VersionInfo | PlainMessage<VersionInfo> | undefined): boolean {
    return proto2.util.equals(VersionInfo, a, b);
  }
}

/**
 * @generated from message license_protocol.SignedMessage
 */
export class SignedMessage extends Message<SignedMessage> {
  /**
   * @generated from field: optional license_protocol.SignedMessage.MessageType type = 1;
   */
  type?: SignedMessage_MessageType;

  /**
   * @generated from field: optional bytes msg = 2;
   */
  msg?: Uint8Array;

  /**
   * Required field that contains the signature of the bytes of msg.
   * For license requests, the signing algorithm is determined by the
   * certificate contained in the request.
   * For license responses, the signing algorithm is HMAC with signing key based
   * on |session_key|.
   *
   * @generated from field: optional bytes signature = 3;
   */
  signature?: Uint8Array;

  /**
   * If populated, the contents of this field will be signaled by the
   * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
   * key is the bytes of an encrypted AES key. If the |session_key_type| is
   * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
   * serialized ECC public key.
   *
   * @generated from field: optional bytes session_key = 4;
   */
  sessionKey?: Uint8Array;

  /**
   * Remote attestation data which will be present in the initial license
   * request for ChromeOS client devices operating in verified mode. Remote
   * attestation challenge data is |msg| field above. Optional.
   *
   * @generated from field: optional bytes remote_attestation = 5;
   */
  remoteAttestation?: Uint8Array;

  /**
   * @generated from field: repeated license_protocol.MetricData metric_data = 6;
   */
  metricData: MetricData[] = [];

  /**
   * Version information from the SDK and license service. This information is
   * provided in the license response.
   *
   * @generated from field: optional license_protocol.VersionInfo service_version_info = 7;
   */
  serviceVersionInfo?: VersionInfo;

  /**
   * Optional field that contains the algorithm type used to generate the
   * session_key and signature in a LICENSE message.
   *
   * @generated from field: optional license_protocol.SignedMessage.SessionKeyType session_key_type = 8 [default = WRAPPED_AES_KEY];
   */
  sessionKeyType?: SignedMessage_SessionKeyType;

  /**
   * The core message is the simple serialization of fields used by OEMCrypto.
   * This field was introduced in OEMCrypto API v16.
   *
   * @generated from field: optional bytes oemcrypto_core_message = 9;
   */
  oemcryptoCoreMessage?: Uint8Array;

  constructor(data?: PartialMessage<SignedMessage>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.SignedMessage";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto2.getEnumType(SignedMessage_MessageType), opt: true },
    { no: 2, name: "msg", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "session_key", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "remote_attestation", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 6, name: "metric_data", kind: "message", T: MetricData, repeated: true },
    { no: 7, name: "service_version_info", kind: "message", T: VersionInfo, opt: true },
    {
      no: 8,
      name: "session_key_type",
      kind: "enum",
      T: proto2.getEnumType(SignedMessage_SessionKeyType),
      opt: true,
      default: SignedMessage_SessionKeyType.WRAPPED_AES_KEY
    },
    { no: 9, name: "oemcrypto_core_message", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignedMessage {
    return new SignedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignedMessage {
    return new SignedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignedMessage {
    return new SignedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: SignedMessage | PlainMessage<SignedMessage> | undefined, b: SignedMessage | PlainMessage<SignedMessage> | undefined): boolean {
    return proto2.util.equals(SignedMessage, a, b);
  }
}

/**
 * @generated from enum license_protocol.SignedMessage.MessageType
 */
export enum SignedMessage_MessageType {
  /**
   * @generated from enum value: LICENSE_REQUEST = 1;
   */
  LICENSE_REQUEST = 1,

  /**
   * @generated from enum value: LICENSE = 2;
   */
  LICENSE = 2,

  /**
   * @generated from enum value: ERROR_RESPONSE = 3;
   */
  ERROR_RESPONSE = 3,

  /**
   * @generated from enum value: SERVICE_CERTIFICATE_REQUEST = 4;
   */
  SERVICE_CERTIFICATE_REQUEST = 4,

  /**
   * @generated from enum value: SERVICE_CERTIFICATE = 5;
   */
  SERVICE_CERTIFICATE = 5,

  /**
   * @generated from enum value: SUB_LICENSE = 6;
   */
  SUB_LICENSE = 6,

  /**
   * @generated from enum value: CAS_LICENSE_REQUEST = 7;
   */
  CAS_LICENSE_REQUEST = 7,

  /**
   * @generated from enum value: CAS_LICENSE = 8;
   */
  CAS_LICENSE = 8,

  /**
   * @generated from enum value: EXTERNAL_LICENSE_REQUEST = 9;
   */
  EXTERNAL_LICENSE_REQUEST = 9,

  /**
   * @generated from enum value: EXTERNAL_LICENSE = 10;
   */
  EXTERNAL_LICENSE = 10
}
// Retrieve enum metadata with: proto2.getEnumType(SignedMessage_MessageType)
proto2.util.setEnumType(SignedMessage_MessageType, "license_protocol.SignedMessage.MessageType", [
  { no: 1, name: "LICENSE_REQUEST" },
  { no: 2, name: "LICENSE" },
  { no: 3, name: "ERROR_RESPONSE" },
  { no: 4, name: "SERVICE_CERTIFICATE_REQUEST" },
  { no: 5, name: "SERVICE_CERTIFICATE" },
  { no: 6, name: "SUB_LICENSE" },
  { no: 7, name: "CAS_LICENSE_REQUEST" },
  { no: 8, name: "CAS_LICENSE" },
  { no: 9, name: "EXTERNAL_LICENSE_REQUEST" },
  { no: 10, name: "EXTERNAL_LICENSE" }
]);

/**
 * @generated from enum license_protocol.SignedMessage.SessionKeyType
 */
export enum SignedMessage_SessionKeyType {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: WRAPPED_AES_KEY = 1;
   */
  WRAPPED_AES_KEY = 1,

  /**
   * @generated from enum value: EPHERMERAL_ECC_PUBLIC_KEY = 2;
   */
  EPHERMERAL_ECC_PUBLIC_KEY = 2
}
// Retrieve enum metadata with: proto2.getEnumType(SignedMessage_SessionKeyType)
proto2.util.setEnumType(SignedMessage_SessionKeyType, "license_protocol.SignedMessage.SessionKeyType", [
  { no: 0, name: "UNDEFINED" },
  { no: 1, name: "WRAPPED_AES_KEY" },
  { no: 2, name: "EPHERMERAL_ECC_PUBLIC_KEY" }
]);

/**
 * ClientIdentification message used to authenticate the client device.
 *
 * @generated from message license_protocol.ClientIdentification
 */
export class ClientIdentification extends Message<ClientIdentification> {
  /**
   * Type of factory-provisioned device root of trust. Optional.
   *
   * @generated from field: optional license_protocol.ClientIdentification.TokenType type = 1 [default = KEYBOX];
   */
  type?: ClientIdentification_TokenType;

  /**
   * Factory-provisioned device root of trust. Required.
   *
   * @generated from field: optional bytes token = 2;
   */
  token?: Uint8Array;

  /**
   * Optional client information name/value pairs.
   *
   * @generated from field: repeated license_protocol.ClientIdentification.NameValue client_info = 3;
   */
  clientInfo: ClientIdentification_NameValue[] = [];

  /**
   * Client token generated by the content provider. Optional.
   *
   * @generated from field: optional bytes provider_client_token = 4;
   */
  providerClientToken?: Uint8Array;

  /**
   * Number of licenses received by the client to which the token above belongs.
   * Only present if client_token is specified.
   *
   * @generated from field: optional uint32 license_counter = 5;
   */
  licenseCounter?: number;

  /**
   * List of non-baseline client capabilities.
   *
   * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities client_capabilities = 6;
   */
  clientCapabilities?: ClientIdentification_ClientCapabilities;

  /**
   * Serialized VmpData message. Optional.
   *
   * @generated from field: optional bytes vmp_data = 7;
   */
  vmpData?: Uint8Array;

  /**
   * Optional field that may contain additional provisioning credentials.
   *
   * @generated from field: repeated license_protocol.ClientIdentification.ClientCredentials device_credentials = 8;
   */
  deviceCredentials: ClientIdentification_ClientCredentials[] = [];

  constructor(data?: PartialMessage<ClientIdentification>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.ClientIdentification";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    {
      no: 1,
      name: "type",
      kind: "enum",
      T: proto2.getEnumType(ClientIdentification_TokenType),
      opt: true,
      default: ClientIdentification_TokenType.KEYBOX
    },
    { no: 2, name: "token", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "client_info", kind: "message", T: ClientIdentification_NameValue, repeated: true },
    { no: 4, name: "provider_client_token", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "license_counter", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "client_capabilities", kind: "message", T: ClientIdentification_ClientCapabilities, opt: true },
    { no: 7, name: "vmp_data", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 8, name: "device_credentials", kind: "message", T: ClientIdentification_ClientCredentials, repeated: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientIdentification {
    return new ClientIdentification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientIdentification {
    return new ClientIdentification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientIdentification {
    return new ClientIdentification().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClientIdentification | PlainMessage<ClientIdentification> | undefined,
    b: ClientIdentification | PlainMessage<ClientIdentification> | undefined
  ): boolean {
    return proto2.util.equals(ClientIdentification, a, b);
  }
}

/**
 * @generated from enum license_protocol.ClientIdentification.TokenType
 */
export enum ClientIdentification_TokenType {
  /**
   * @generated from enum value: KEYBOX = 0;
   */
  KEYBOX = 0,

  /**
   * @generated from enum value: DRM_DEVICE_CERTIFICATE = 1;
   */
  DRM_DEVICE_CERTIFICATE = 1,

  /**
   * @generated from enum value: REMOTE_ATTESTATION_CERTIFICATE = 2;
   */
  REMOTE_ATTESTATION_CERTIFICATE = 2,

  /**
   * @generated from enum value: OEM_DEVICE_CERTIFICATE = 3;
   */
  OEM_DEVICE_CERTIFICATE = 3
}
// Retrieve enum metadata with: proto2.getEnumType(ClientIdentification_TokenType)
proto2.util.setEnumType(ClientIdentification_TokenType, "license_protocol.ClientIdentification.TokenType", [
  { no: 0, name: "KEYBOX" },
  { no: 1, name: "DRM_DEVICE_CERTIFICATE" },
  { no: 2, name: "REMOTE_ATTESTATION_CERTIFICATE" },
  { no: 3, name: "OEM_DEVICE_CERTIFICATE" }
]);

/**
 * @generated from message license_protocol.ClientIdentification.NameValue
 */
export class ClientIdentification_NameValue extends Message<ClientIdentification_NameValue> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: optional string value = 2;
   */
  value?: string;

  constructor(data?: PartialMessage<ClientIdentification_NameValue>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.ClientIdentification.NameValue";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientIdentification_NameValue {
    return new ClientIdentification_NameValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientIdentification_NameValue {
    return new ClientIdentification_NameValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientIdentification_NameValue {
    return new ClientIdentification_NameValue().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClientIdentification_NameValue | PlainMessage<ClientIdentification_NameValue> | undefined,
    b: ClientIdentification_NameValue | PlainMessage<ClientIdentification_NameValue> | undefined
  ): boolean {
    return proto2.util.equals(ClientIdentification_NameValue, a, b);
  }
}

/**
 * Capabilities which not all clients may support. Used for the license
 * exchange protocol only.
 *
 * @generated from message license_protocol.ClientIdentification.ClientCapabilities
 */
export class ClientIdentification_ClientCapabilities extends Message<ClientIdentification_ClientCapabilities> {
  /**
   * @generated from field: optional bool client_token = 1 [default = false];
   */
  clientToken?: boolean;

  /**
   * @generated from field: optional bool session_token = 2 [default = false];
   */
  sessionToken?: boolean;

  /**
   * @generated from field: optional bool video_resolution_constraints = 3 [default = false];
   */
  videoResolutionConstraints?: boolean;

  /**
   * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4 [default = HDCP_NONE];
   */
  maxHdcpVersion?: ClientIdentification_ClientCapabilities_HdcpVersion;

  /**
   * @generated from field: optional uint32 oem_crypto_api_version = 5;
   */
  oemCryptoApiVersion?: number;

  /**
   * Client has hardware support for protecting the usage table, such as
   * storing the generation number in secure memory.  For Details, see:
   * Widevine Modular DRM Security Integration Guide for CENC
   *
   * @generated from field: optional bool anti_rollback_usage_table = 6 [default = false];
   */
  antiRollbackUsageTable?: boolean;

  /**
   * The client shall report |srm_version| if available.
   *
   * @generated from field: optional uint32 srm_version = 7;
   */
  srmVersion?: number;

  /**
   * A device may have SRM data, and report a version, but may not be capable
   * of updating SRM data.
   *
   * @generated from field: optional bool can_update_srm = 8 [default = false];
   */
  canUpdateSrm?: boolean;

  /**
   * @generated from field: repeated license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;
   */
  supportedCertificateKeyType: ClientIdentification_ClientCapabilities_CertificateKeyType[] = [];

  /**
   * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10 [default = ANALOG_OUTPUT_UNKNOWN];
   */
  analogOutputCapabilities?: ClientIdentification_ClientCapabilities_AnalogOutputCapabilities;

  /**
   * @generated from field: optional bool can_disable_analog_output = 11 [default = false];
   */
  canDisableAnalogOutput?: boolean;

  /**
   * Clients can indicate a performance level supported by OEMCrypto.
   * This will allow applications and providers to choose an appropriate
   * quality of content to serve. Currently defined tiers are
   * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
   * the resource rating is unavailable or reporting erroneous values
   * for that device. For details see,
   * Widevine Modular DRM Security Integration Guide for CENC
   *
   * @generated from field: optional uint32 resource_rating_tier = 12 [default = 0];
   */
  resourceRatingTier?: number;

  constructor(data?: PartialMessage<ClientIdentification_ClientCapabilities>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.ClientIdentification.ClientCapabilities";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "client_token", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 2, name: "session_token", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 3, name: "video_resolution_constraints", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    {
      no: 4,
      name: "max_hdcp_version",
      kind: "enum",
      T: proto2.getEnumType(ClientIdentification_ClientCapabilities_HdcpVersion),
      opt: true,
      default: ClientIdentification_ClientCapabilities_HdcpVersion.HDCP_NONE
    },
    { no: 5, name: "oem_crypto_api_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "anti_rollback_usage_table", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 7, name: "srm_version", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 8, name: "can_update_srm", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    {
      no: 9,
      name: "supported_certificate_key_type",
      kind: "enum",
      T: proto2.getEnumType(ClientIdentification_ClientCapabilities_CertificateKeyType),
      repeated: true
    },
    {
      no: 10,
      name: "analog_output_capabilities",
      kind: "enum",
      T: proto2.getEnumType(ClientIdentification_ClientCapabilities_AnalogOutputCapabilities),
      opt: true,
      default: ClientIdentification_ClientCapabilities_AnalogOutputCapabilities.ANALOG_OUTPUT_UNKNOWN
    },
    { no: 11, name: "can_disable_analog_output", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true, default: false },
    { no: 12, name: "resource_rating_tier", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true, default: 0 }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientIdentification_ClientCapabilities {
    return new ClientIdentification_ClientCapabilities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientIdentification_ClientCapabilities {
    return new ClientIdentification_ClientCapabilities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientIdentification_ClientCapabilities {
    return new ClientIdentification_ClientCapabilities().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClientIdentification_ClientCapabilities | PlainMessage<ClientIdentification_ClientCapabilities> | undefined,
    b: ClientIdentification_ClientCapabilities | PlainMessage<ClientIdentification_ClientCapabilities> | undefined
  ): boolean {
    return proto2.util.equals(ClientIdentification_ClientCapabilities, a, b);
  }
}

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion
 */
export enum ClientIdentification_ClientCapabilities_HdcpVersion {
  /**
   * @generated from enum value: HDCP_NONE = 0;
   */
  HDCP_NONE = 0,

  /**
   * @generated from enum value: HDCP_V1 = 1;
   */
  HDCP_V1 = 1,

  /**
   * @generated from enum value: HDCP_V2 = 2;
   */
  HDCP_V2 = 2,

  /**
   * @generated from enum value: HDCP_V2_1 = 3;
   */
  HDCP_V2_1 = 3,

  /**
   * @generated from enum value: HDCP_V2_2 = 4;
   */
  HDCP_V2_2 = 4,

  /**
   * @generated from enum value: HDCP_V2_3 = 5;
   */
  HDCP_V2_3 = 5,

  /**
   * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
   */
  HDCP_NO_DIGITAL_OUTPUT = 255
}
// Retrieve enum metadata with: proto2.getEnumType(ClientIdentification_ClientCapabilities_HdcpVersion)
proto2.util.setEnumType(ClientIdentification_ClientCapabilities_HdcpVersion, "license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion", [
  { no: 0, name: "HDCP_NONE" },
  { no: 1, name: "HDCP_V1" },
  { no: 2, name: "HDCP_V2" },
  { no: 3, name: "HDCP_V2_1" },
  { no: 4, name: "HDCP_V2_2" },
  { no: 5, name: "HDCP_V2_3" },
  { no: 255, name: "HDCP_NO_DIGITAL_OUTPUT" }
]);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType
 */
export enum ClientIdentification_ClientCapabilities_CertificateKeyType {
  /**
   * @generated from enum value: RSA_2048 = 0;
   */
  RSA_2048 = 0,

  /**
   * @generated from enum value: RSA_3072 = 1;
   */
  RSA_3072 = 1,

  /**
   * @generated from enum value: ECC_SECP256R1 = 2;
   */
  ECC_SECP256R1 = 2,

  /**
   * @generated from enum value: ECC_SECP384R1 = 3;
   */
  ECC_SECP384R1 = 3,

  /**
   * @generated from enum value: ECC_SECP521R1 = 4;
   */
  ECC_SECP521R1 = 4
}
// Retrieve enum metadata with: proto2.getEnumType(ClientIdentification_ClientCapabilities_CertificateKeyType)
proto2.util.setEnumType(
  ClientIdentification_ClientCapabilities_CertificateKeyType,
  "license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType",
  [
    { no: 0, name: "RSA_2048" },
    { no: 1, name: "RSA_3072" },
    { no: 2, name: "ECC_SECP256R1" },
    { no: 3, name: "ECC_SECP384R1" },
    { no: 4, name: "ECC_SECP521R1" }
  ]
);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities
 */
export enum ClientIdentification_ClientCapabilities_AnalogOutputCapabilities {
  /**
   * @generated from enum value: ANALOG_OUTPUT_UNKNOWN = 0;
   */
  ANALOG_OUTPUT_UNKNOWN = 0,

  /**
   * @generated from enum value: ANALOG_OUTPUT_NONE = 1;
   */
  ANALOG_OUTPUT_NONE = 1,

  /**
   * @generated from enum value: ANALOG_OUTPUT_SUPPORTED = 2;
   */
  ANALOG_OUTPUT_SUPPORTED = 2,

  /**
   * @generated from enum value: ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3;
   */
  ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3
}
// Retrieve enum metadata with: proto2.getEnumType(ClientIdentification_ClientCapabilities_AnalogOutputCapabilities)
proto2.util.setEnumType(
  ClientIdentification_ClientCapabilities_AnalogOutputCapabilities,
  "license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities",
  [
    { no: 0, name: "ANALOG_OUTPUT_UNKNOWN" },
    { no: 1, name: "ANALOG_OUTPUT_NONE" },
    { no: 2, name: "ANALOG_OUTPUT_SUPPORTED" },
    { no: 3, name: "ANALOG_OUTPUT_SUPPORTS_CGMS_A" }
  ]
);

/**
 * @generated from message license_protocol.ClientIdentification.ClientCredentials
 */
export class ClientIdentification_ClientCredentials extends Message<ClientIdentification_ClientCredentials> {
  /**
   * @generated from field: optional license_protocol.ClientIdentification.TokenType type = 1 [default = KEYBOX];
   */
  type?: ClientIdentification_TokenType;

  /**
   * @generated from field: optional bytes token = 2;
   */
  token?: Uint8Array;

  constructor(data?: PartialMessage<ClientIdentification_ClientCredentials>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.ClientIdentification.ClientCredentials";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    {
      no: 1,
      name: "type",
      kind: "enum",
      T: proto2.getEnumType(ClientIdentification_TokenType),
      opt: true,
      default: ClientIdentification_TokenType.KEYBOX
    },
    { no: 2, name: "token", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientIdentification_ClientCredentials {
    return new ClientIdentification_ClientCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientIdentification_ClientCredentials {
    return new ClientIdentification_ClientCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientIdentification_ClientCredentials {
    return new ClientIdentification_ClientCredentials().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClientIdentification_ClientCredentials | PlainMessage<ClientIdentification_ClientCredentials> | undefined,
    b: ClientIdentification_ClientCredentials | PlainMessage<ClientIdentification_ClientCredentials> | undefined
  ): boolean {
    return proto2.util.equals(ClientIdentification_ClientCredentials, a, b);
  }
}

/**
 * EncryptedClientIdentification message used to hold ClientIdentification
 * messages encrypted for privacy purposes.
 *
 * @generated from message license_protocol.EncryptedClientIdentification
 */
export class EncryptedClientIdentification extends Message<EncryptedClientIdentification> {
  /**
   * Provider ID for which the ClientIdentifcation is encrypted (owner of
   * service certificate).
   *
   * @generated from field: optional string provider_id = 1;
   */
  providerId?: string;

  /**
   * Serial number for the service certificate for which ClientIdentification is
   * encrypted.
   *
   * @generated from field: optional bytes service_certificate_serial_number = 2;
   */
  serviceCertificateSerialNumber?: Uint8Array;

  /**
   * Serialized ClientIdentification message, encrypted with the privacy key
   * using AES-128-CBC with PKCS#5 padding.
   *
   * @generated from field: optional bytes encrypted_client_id = 3;
   */
  encryptedClientId?: Uint8Array;

  /**
   * Initialization vector needed to decrypt encrypted_client_id.
   *
   * @generated from field: optional bytes encrypted_client_id_iv = 4;
   */
  encryptedClientIdIv?: Uint8Array;

  /**
   * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
   *
   * @generated from field: optional bytes encrypted_privacy_key = 5;
   */
  encryptedPrivacyKey?: Uint8Array;

  constructor(data?: PartialMessage<EncryptedClientIdentification>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.EncryptedClientIdentification";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "provider_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "service_certificate_serial_number", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "encrypted_client_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "encrypted_client_id_iv", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "encrypted_privacy_key", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptedClientIdentification {
    return new EncryptedClientIdentification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptedClientIdentification {
    return new EncryptedClientIdentification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptedClientIdentification {
    return new EncryptedClientIdentification().fromJsonString(jsonString, options);
  }

  static equals(
    a: EncryptedClientIdentification | PlainMessage<EncryptedClientIdentification> | undefined,
    b: EncryptedClientIdentification | PlainMessage<EncryptedClientIdentification> | undefined
  ): boolean {
    return proto2.util.equals(EncryptedClientIdentification, a, b);
  }
}

/**
 * DRM certificate definition for user devices, intermediate, service, and root
 * certificates.
 *
 * @generated from message license_protocol.DrmCertificate
 */
export class DrmCertificate extends Message<DrmCertificate> {
  /**
   * Type of certificate. Required.
   *
   * @generated from field: optional license_protocol.DrmCertificate.Type type = 1;
   */
  type?: DrmCertificate_Type;

  /**
   * 128-bit globally unique serial number of certificate.
   * Value is 0 for root certificate. Required.
   *
   * @generated from field: optional bytes serial_number = 2;
   */
  serialNumber?: Uint8Array;

  /**
   * POSIX time, in seconds, when the certificate was created. Required.
   *
   * @generated from field: optional uint32 creation_time_seconds = 3;
   */
  creationTimeSeconds?: number;

  /**
   * POSIX time, in seconds, when the certificate should expire. Value of zero
   * denotes indefinite expiry time. For more information on limited lifespan
   * DRM certificates see (go/limited-lifespan-drm-certificates).
   *
   * @generated from field: optional uint32 expiration_time_seconds = 12;
   */
  expirationTimeSeconds?: number;

  /**
   * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
   *
   * @generated from field: optional bytes public_key = 4;
   */
  publicKey?: Uint8Array;

  /**
   * Widevine system ID for the device. Required for intermediate and
   * user device certificates.
   *
   * @generated from field: optional uint32 system_id = 5;
   */
  systemId?: number;

  /**
   * Deprecated field, which used to indicate whether the device was a test
   * (non-production) device. The test_device field in ProvisionedDeviceInfo
   * below should be observed instead.
   *
   * @generated from field: optional bool test_device_deprecated = 6 [deprecated = true];
   * @deprecated
   */
  testDeviceDeprecated?: boolean;

  /**
   * Service identifier (web origin) for the provider which owns the
   * certificate. Required for service and provisioner certificates.
   *
   * @generated from field: optional string provider_id = 7;
   */
  providerId?: string;

  /**
   * This field is used only when type = SERVICE to specify which SDK uses
   * service certificate. This repeated field is treated as a set. A certificate
   * may be used for the specified service SDK if the appropriate ServiceType
   * is specified in this field.
   *
   * @generated from field: repeated license_protocol.DrmCertificate.ServiceType service_types = 8;
   */
  serviceTypes: DrmCertificate_ServiceType[] = [];

  /**
   * Required. The algorithm field contains the curve used to create the
   * |public_key| if algorithm is one of the ECC types.
   * The |algorithm| is used for both to determine the if the certificate is ECC
   * or RSA. The |algorithm| also specifies the parameters that were used to
   * create |public_key| and are used to create an ephemeral session key.
   *
   * @generated from field: optional license_protocol.DrmCertificate.Algorithm algorithm = 9 [default = RSA];
   */
  algorithm?: DrmCertificate_Algorithm;

  /**
   * Optional. May be present in DEVICE certificate types. This is the root
   * of trust identifier that holds an encrypted value that identifies the
   * keybox or other root of trust that was used to provision a DEVICE drm
   * certificate.
   *
   * @generated from field: optional bytes rot_id = 10;
   */
  rotId?: Uint8Array;

  /**
   * Optional. May be present in devices that explicitly support dual keys. When
   * present the |public_key| is used for verification of received license
   * request messages.
   *
   * @generated from field: optional license_protocol.DrmCertificate.EncryptionKey encryption_key = 11;
   */
  encryptionKey?: DrmCertificate_EncryptionKey;

  constructor(data?: PartialMessage<DrmCertificate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.DrmCertificate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto2.getEnumType(DrmCertificate_Type), opt: true },
    { no: 2, name: "serial_number", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "creation_time_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 12, name: "expiration_time_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 4, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "system_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "test_device_deprecated", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "provider_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "service_types", kind: "enum", T: proto2.getEnumType(DrmCertificate_ServiceType), repeated: true },
    { no: 9, name: "algorithm", kind: "enum", T: proto2.getEnumType(DrmCertificate_Algorithm), opt: true, default: DrmCertificate_Algorithm.RSA },
    { no: 10, name: "rot_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 11, name: "encryption_key", kind: "message", T: DrmCertificate_EncryptionKey, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DrmCertificate {
    return new DrmCertificate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DrmCertificate {
    return new DrmCertificate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DrmCertificate {
    return new DrmCertificate().fromJsonString(jsonString, options);
  }

  static equals(a: DrmCertificate | PlainMessage<DrmCertificate> | undefined, b: DrmCertificate | PlainMessage<DrmCertificate> | undefined): boolean {
    return proto2.util.equals(DrmCertificate, a, b);
  }
}

/**
 * @generated from enum license_protocol.DrmCertificate.Type
 */
export enum DrmCertificate_Type {
  /**
   * ProtoBestPractices: ignore.
   *
   * @generated from enum value: ROOT = 0;
   */
  ROOT = 0,

  /**
   * @generated from enum value: DEVICE_MODEL = 1;
   */
  DEVICE_MODEL = 1,

  /**
   * @generated from enum value: DEVICE = 2;
   */
  DEVICE = 2,

  /**
   * @generated from enum value: SERVICE = 3;
   */
  SERVICE = 3,

  /**
   * @generated from enum value: PROVISIONER = 4;
   */
  PROVISIONER = 4
}
// Retrieve enum metadata with: proto2.getEnumType(DrmCertificate_Type)
proto2.util.setEnumType(DrmCertificate_Type, "license_protocol.DrmCertificate.Type", [
  { no: 0, name: "ROOT" },
  { no: 1, name: "DEVICE_MODEL" },
  { no: 2, name: "DEVICE" },
  { no: 3, name: "SERVICE" },
  { no: 4, name: "PROVISIONER" }
]);

/**
 * @generated from enum license_protocol.DrmCertificate.ServiceType
 */
export enum DrmCertificate_ServiceType {
  /**
   * @generated from enum value: UNKNOWN_SERVICE_TYPE = 0;
   */
  UNKNOWN_SERVICE_TYPE = 0,

  /**
   * @generated from enum value: LICENSE_SERVER_SDK = 1;
   */
  LICENSE_SERVER_SDK = 1,

  /**
   * @generated from enum value: LICENSE_SERVER_PROXY_SDK = 2;
   */
  LICENSE_SERVER_PROXY_SDK = 2,

  /**
   * @generated from enum value: PROVISIONING_SDK = 3;
   */
  PROVISIONING_SDK = 3,

  /**
   * @generated from enum value: CAS_PROXY_SDK = 4;
   */
  CAS_PROXY_SDK = 4
}
// Retrieve enum metadata with: proto2.getEnumType(DrmCertificate_ServiceType)
proto2.util.setEnumType(DrmCertificate_ServiceType, "license_protocol.DrmCertificate.ServiceType", [
  { no: 0, name: "UNKNOWN_SERVICE_TYPE" },
  { no: 1, name: "LICENSE_SERVER_SDK" },
  { no: 2, name: "LICENSE_SERVER_PROXY_SDK" },
  { no: 3, name: "PROVISIONING_SDK" },
  { no: 4, name: "CAS_PROXY_SDK" }
]);

/**
 * @generated from enum license_protocol.DrmCertificate.Algorithm
 */
export enum DrmCertificate_Algorithm {
  /**
   * @generated from enum value: UNKNOWN_ALGORITHM = 0;
   */
  UNKNOWN_ALGORITHM = 0,

  /**
   * @generated from enum value: RSA = 1;
   */
  RSA = 1,

  /**
   * @generated from enum value: ECC_SECP256R1 = 2;
   */
  ECC_SECP256R1 = 2,

  /**
   * @generated from enum value: ECC_SECP384R1 = 3;
   */
  ECC_SECP384R1 = 3,

  /**
   * @generated from enum value: ECC_SECP521R1 = 4;
   */
  ECC_SECP521R1 = 4
}
// Retrieve enum metadata with: proto2.getEnumType(DrmCertificate_Algorithm)
proto2.util.setEnumType(DrmCertificate_Algorithm, "license_protocol.DrmCertificate.Algorithm", [
  { no: 0, name: "UNKNOWN_ALGORITHM" },
  { no: 1, name: "RSA" },
  { no: 2, name: "ECC_SECP256R1" },
  { no: 3, name: "ECC_SECP384R1" },
  { no: 4, name: "ECC_SECP521R1" }
]);

/**
 * @generated from message license_protocol.DrmCertificate.EncryptionKey
 */
export class DrmCertificate_EncryptionKey extends Message<DrmCertificate_EncryptionKey> {
  /**
   * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
   *
   * @generated from field: optional bytes public_key = 1;
   */
  publicKey?: Uint8Array;

  /**
   * Required. The algorithm field contains the curve used to create the
   * |public_key| if algorithm is one of the ECC types.
   * The |algorithm| is used for both to determine the if the certificate is
   * ECC or RSA. The |algorithm| also specifies the parameters that were used
   * to create |public_key| and are used to create an ephemeral session key.
   *
   * @generated from field: optional license_protocol.DrmCertificate.Algorithm algorithm = 2 [default = RSA];
   */
  algorithm?: DrmCertificate_Algorithm;

  constructor(data?: PartialMessage<DrmCertificate_EncryptionKey>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.DrmCertificate.EncryptionKey";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "algorithm", kind: "enum", T: proto2.getEnumType(DrmCertificate_Algorithm), opt: true, default: DrmCertificate_Algorithm.RSA }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DrmCertificate_EncryptionKey {
    return new DrmCertificate_EncryptionKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DrmCertificate_EncryptionKey {
    return new DrmCertificate_EncryptionKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DrmCertificate_EncryptionKey {
    return new DrmCertificate_EncryptionKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: DrmCertificate_EncryptionKey | PlainMessage<DrmCertificate_EncryptionKey> | undefined,
    b: DrmCertificate_EncryptionKey | PlainMessage<DrmCertificate_EncryptionKey> | undefined
  ): boolean {
    return proto2.util.equals(DrmCertificate_EncryptionKey, a, b);
  }
}

/**
 * DrmCertificate signed by a higher (CA) DRM certificate.
 *
 * @generated from message license_protocol.SignedDrmCertificate
 */
export class SignedDrmCertificate extends Message<SignedDrmCertificate> {
  /**
   * Serialized certificate. Required.
   *
   * @generated from field: optional bytes drm_certificate = 1;
   */
  drmCertificate?: Uint8Array;

  /**
   * Signature of certificate. Signed with root or intermediate
   * certificate specified below. Required.
   *
   * @generated from field: optional bytes signature = 2;
   */
  signature?: Uint8Array;

  /**
   * SignedDrmCertificate used to sign this certificate.
   *
   * @generated from field: optional license_protocol.SignedDrmCertificate signer = 3;
   */
  signer?: SignedDrmCertificate;

  /**
   * Optional field that indicates the hash algorithm used in signature scheme.
   *
   * @generated from field: optional license_protocol.HashAlgorithmProto hash_algorithm = 4;
   */
  hashAlgorithm?: HashAlgorithmProto;

  constructor(data?: PartialMessage<SignedDrmCertificate>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.SignedDrmCertificate";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "drm_certificate", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "signer", kind: "message", T: SignedDrmCertificate, opt: true },
    { no: 4, name: "hash_algorithm", kind: "enum", T: proto2.getEnumType(HashAlgorithmProto), opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignedDrmCertificate {
    return new SignedDrmCertificate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignedDrmCertificate {
    return new SignedDrmCertificate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignedDrmCertificate {
    return new SignedDrmCertificate().fromJsonString(jsonString, options);
  }

  static equals(
    a: SignedDrmCertificate | PlainMessage<SignedDrmCertificate> | undefined,
    b: SignedDrmCertificate | PlainMessage<SignedDrmCertificate> | undefined
  ): boolean {
    return proto2.util.equals(SignedDrmCertificate, a, b);
  }
}

/**
 * @generated from message license_protocol.WidevinePsshData
 */
export class WidevinePsshData extends Message<WidevinePsshData> {
  /**
   * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
   * PSSHs. May be repeated to facilitate delivery of multiple keys in a
   * single license. Cannot be used in conjunction with content_id or
   * group_ids, which are the preferred mechanism.
   *
   * @generated from field: repeated bytes key_ids = 2;
   */
  keyIds: Uint8Array[] = [];

  /**
   * Content identifier which may map to multiple entitlement or content key
   * IDs to facilitate the delivery of multiple keys in a single license.
   * Cannot be present in conjunction with key_ids, but if used must be in all
   * PSSHs.
   *
   * @generated from field: optional bytes content_id = 4;
   */
  contentId?: Uint8Array;

  /**
   * Crypto period index, for media using key rotation. Always corresponds to
   * The content key period. This means that if using entitlement licensing
   * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
   * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
   * key rotation.
   *
   * @generated from field: optional uint32 crypto_period_index = 7;
   */
  cryptoPeriodIndex?: number;

  /**
   * Protection scheme identifying the encryption algorithm. The protection
   * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
   * representing a single ascii character in one of the 4CC protection scheme
   * values. To be deprecated in favor of signaling from content.
   * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
   * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
   * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
   * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
   *
   * @generated from field: optional uint32 protection_scheme = 9;
   */
  protectionScheme?: number;

  /**
   * Optional. For media using key rotation, this represents the duration
   * of each crypto period in seconds.
   *
   * @generated from field: optional uint32 crypto_period_seconds = 10;
   */
  cryptoPeriodSeconds?: number;

  /**
   * Type of PSSH. Required if not SINGLE.
   *
   * @generated from field: optional license_protocol.WidevinePsshData.Type type = 11 [default = SINGLE];
   */
  type?: WidevinePsshData_Type;

  /**
   * Key sequence for Widevine-managed keys. Optional.
   *
   * @generated from field: optional uint32 key_sequence = 12;
   */
  keySequence?: number;

  /**
   * Group identifiers for all groups to which the content belongs. This can
   * be used to deliver licenses to unlock multiple titles / channels.
   * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
   * not in conjunction with key_ids.
   *
   * @generated from field: repeated bytes group_ids = 13;
   */
  groupIds: Uint8Array[] = [];

  /**
   * Copy/copies of the content key used to decrypt the media stream in which
   * the PSSH box is embedded, each wrapped with a different entitlement key.
   * May also contain sub-licenses to support devices with OEMCrypto 13 or
   * older. May be repeated if using group entitlement keys. Present only in
   * PSSHs of type ENTITLED_KEY.
   *
   * @generated from field: repeated license_protocol.WidevinePsshData.EntitledKey entitled_keys = 14;
   */
  entitledKeys: WidevinePsshData_EntitledKey[] = [];

  /**
   * Video feature identifier, which is used in conjunction with |content_id|
   * to determine the set of keys to be returned in the license. Cannot be
   * present in conjunction with |key_ids|.
   * Current values are "HDR".
   *
   * @generated from field: optional string video_feature = 15;
   */
  videoFeature?: string;

  /**
   * @generated from field: optional license_protocol.WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];
   * @deprecated
   */
  algorithm?: WidevinePsshData_Algorithm;

  /**
   * Content provider name.
   *
   * @generated from field: optional string provider = 3 [deprecated = true];
   * @deprecated
   */
  provider?: string;

  /**
   * Track type. Acceptable values are SD, HD and AUDIO. Used to
   * differentiate content keys used by an asset.
   *
   * @generated from field: optional string track_type = 5 [deprecated = true];
   * @deprecated
   */
  trackType?: string;

  /**
   * The name of a registered policy to be used for this asset.
   *
   * @generated from field: optional string policy = 6 [deprecated = true];
   * @deprecated
   */
  policy?: string;

  /**
   * Optional protected context for group content. The grouped_license is a
   * serialized SignedMessage.
   *
   * @generated from field: optional bytes grouped_license = 8 [deprecated = true];
   * @deprecated
   */
  groupedLicense?: Uint8Array;

  constructor(data?: PartialMessage<WidevinePsshData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.WidevinePsshData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 2, name: "key_ids", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 4, name: "content_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 7, name: "crypto_period_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 9, name: "protection_scheme", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 10, name: "crypto_period_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 11, name: "type", kind: "enum", T: proto2.getEnumType(WidevinePsshData_Type), opt: true, default: WidevinePsshData_Type.SINGLE },
    { no: 12, name: "key_sequence", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 13, name: "group_ids", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 14, name: "entitled_keys", kind: "message", T: WidevinePsshData_EntitledKey, repeated: true },
    { no: 15, name: "video_feature", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 1, name: "algorithm", kind: "enum", T: proto2.getEnumType(WidevinePsshData_Algorithm), opt: true },
    { no: 3, name: "provider", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "track_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "policy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "grouped_license", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WidevinePsshData {
    return new WidevinePsshData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WidevinePsshData {
    return new WidevinePsshData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WidevinePsshData {
    return new WidevinePsshData().fromJsonString(jsonString, options);
  }

  static equals(
    a: WidevinePsshData | PlainMessage<WidevinePsshData> | undefined,
    b: WidevinePsshData | PlainMessage<WidevinePsshData> | undefined
  ): boolean {
    return proto2.util.equals(WidevinePsshData, a, b);
  }
}

/**
 * @generated from enum license_protocol.WidevinePsshData.Type
 */
export enum WidevinePsshData_Type {
  /**
   * Single PSSH to be used to retrieve content keys.
   *
   * @generated from enum value: SINGLE = 0;
   */
  SINGLE = 0,

  /**
   * Primary PSSH used to retrieve entitlement keys.
   *
   * @generated from enum value: ENTITLEMENT = 1;
   */
  ENTITLEMENT = 1,

  /**
   * Secondary PSSH containing entitled key(s).
   *
   * @generated from enum value: ENTITLED_KEY = 2;
   */
  ENTITLED_KEY = 2
}
// Retrieve enum metadata with: proto2.getEnumType(WidevinePsshData_Type)
proto2.util.setEnumType(WidevinePsshData_Type, "license_protocol.WidevinePsshData.Type", [
  { no: 0, name: "SINGLE" },
  { no: 1, name: "ENTITLEMENT" },
  { no: 2, name: "ENTITLED_KEY" }
]);

/**
 * //////////////////////////  Deprecated Fields  ////////////////////////////
 *
 * @generated from enum license_protocol.WidevinePsshData.Algorithm
 */
export enum WidevinePsshData_Algorithm {
  /**
   * @generated from enum value: UNENCRYPTED = 0;
   */
  UNENCRYPTED = 0,

  /**
   * @generated from enum value: AESCTR = 1;
   */
  AESCTR = 1
}
// Retrieve enum metadata with: proto2.getEnumType(WidevinePsshData_Algorithm)
proto2.util.setEnumType(WidevinePsshData_Algorithm, "license_protocol.WidevinePsshData.Algorithm", [
  { no: 0, name: "UNENCRYPTED" },
  { no: 1, name: "AESCTR" }
]);

/**
 * @generated from message license_protocol.WidevinePsshData.EntitledKey
 */
export class WidevinePsshData_EntitledKey extends Message<WidevinePsshData_EntitledKey> {
  /**
   * ID of entitlement key used for wrapping |key|.
   *
   * @generated from field: optional bytes entitlement_key_id = 1;
   */
  entitlementKeyId?: Uint8Array;

  /**
   * ID of the entitled key.
   *
   * @generated from field: optional bytes key_id = 2;
   */
  keyId?: Uint8Array;

  /**
   * Wrapped key. Required.
   *
   * @generated from field: optional bytes key = 3;
   */
  key?: Uint8Array;

  /**
   * IV used for wrapping |key|. Required.
   *
   * @generated from field: optional bytes iv = 4;
   */
  iv?: Uint8Array;

  /**
   * Size of entitlement key used for wrapping |key|.
   *
   * @generated from field: optional uint32 entitlement_key_size_bytes = 5 [default = 32];
   */
  entitlementKeySizeBytes?: number;

  constructor(data?: PartialMessage<WidevinePsshData_EntitledKey>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.WidevinePsshData.EntitledKey";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "entitlement_key_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "key_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 3, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "iv", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "entitlement_key_size_bytes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true, default: 32 }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WidevinePsshData_EntitledKey {
    return new WidevinePsshData_EntitledKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WidevinePsshData_EntitledKey {
    return new WidevinePsshData_EntitledKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WidevinePsshData_EntitledKey {
    return new WidevinePsshData_EntitledKey().fromJsonString(jsonString, options);
  }

  static equals(
    a: WidevinePsshData_EntitledKey | PlainMessage<WidevinePsshData_EntitledKey> | undefined,
    b: WidevinePsshData_EntitledKey | PlainMessage<WidevinePsshData_EntitledKey> | undefined
  ): boolean {
    return proto2.util.equals(WidevinePsshData_EntitledKey, a, b);
  }
}

/**
 * File Hashes for Verified Media Path (VMP) support.
 *
 * @generated from message license_protocol.FileHashes
 */
export class FileHashes extends Message<FileHashes> {
  /**
   * @generated from field: optional bytes signer = 1;
   */
  signer?: Uint8Array;

  /**
   * @generated from field: repeated license_protocol.FileHashes.Signature signatures = 2;
   */
  signatures: FileHashes_Signature[] = [];

  constructor(data?: PartialMessage<FileHashes>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.FileHashes";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 2, name: "signatures", kind: "message", T: FileHashes_Signature, repeated: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileHashes {
    return new FileHashes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileHashes {
    return new FileHashes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileHashes {
    return new FileHashes().fromJsonString(jsonString, options);
  }

  static equals(a: FileHashes | PlainMessage<FileHashes> | undefined, b: FileHashes | PlainMessage<FileHashes> | undefined): boolean {
    return proto2.util.equals(FileHashes, a, b);
  }
}

/**
 * @generated from message license_protocol.FileHashes.Signature
 */
export class FileHashes_Signature extends Message<FileHashes_Signature> {
  /**
   * @generated from field: optional string filename = 1;
   */
  filename?: string;

  /**
   * 0 - release, 1 - testing
   *
   * @generated from field: optional bool test_signing = 2;
   */
  testSigning?: boolean;

  /**
   * @generated from field: optional bytes SHA512Hash = 3;
   */
  SHA512Hash?: Uint8Array;

  /**
   * 0 for dlls, 1 for exe, this is field 3 in file
   *
   * @generated from field: optional bool main_exe = 4;
   */
  mainExe?: boolean;

  /**
   * @generated from field: optional bytes signature = 5;
   */
  signature?: Uint8Array;

  constructor(data?: PartialMessage<FileHashes_Signature>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "license_protocol.FileHashes.Signature";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "test_signing", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "SHA512Hash", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 4, name: "main_exe", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true }
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileHashes_Signature {
    return new FileHashes_Signature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileHashes_Signature {
    return new FileHashes_Signature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileHashes_Signature {
    return new FileHashes_Signature().fromJsonString(jsonString, options);
  }

  static equals(
    a: FileHashes_Signature | PlainMessage<FileHashes_Signature> | undefined,
    b: FileHashes_Signature | PlainMessage<FileHashes_Signature> | undefined
  ): boolean {
    return proto2.util.equals(FileHashes_Signature, a, b);
  }
}
